还有快速排序和归并排序没有用代码实现！！！！

1. ==快速排序==（分治排序）：O(n * logn)速度较快 
2. 选择排序：O(n * n)  速度较慢  每一次循环从里面`选择`一个最大的元素或最小的元素出来
3. 冒泡排序：O(n * n) 主要是对相邻的两个数进行比较，然后交换位置。
4. 插入排序：O(n * n)
5. ==堆排序==：O(n * logn)
6. 归并排序：O(n * logn)
7. 桶排序

> 快速排序就是个二叉树的前序遍历。归并排序就是二叉树的后序遍历
>
> 稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。
>
> 稳定也可以理解为一切皆在掌握中,元素的位置处在你在控制中.而不稳定算法有时就有点碰运气,随机的成分.当两元素相等时它们的位置在排序后可能仍然相同.但也可能不同.是未可知的

## 1.选择排序：

```javascript
let arr = [3,5,8,1,6,9]
for(let i = 0; i < arr.length; i++) {
    let min = arr[i];
    for(let j = i + 1; j < arr.length; j++) {
        if (arr[j] < min) {
            min = arr[j];
            arr[j] = arr[i];
            arr[i] = min
        }
    }
}
console.log('arr:',arr)
```

## 2.冒泡排序：主要是对相邻的两个数进行比较，然后交换位置

```javascript
let arr = [3,5,8,1,6,9]
for(let i = 0; i < arr.length; i++) {
    for (let j = arr.length - i - 1; j > 0; j--) {
        if (arr[j] < arr[j-1]) {
            let temp = arr[j-1];
            arr[j-1] = arr[j];
            arr[j] = temp
        }
    }
}
console.log('arr:',arr)

// 下面这种写法也可以
let arr = [3,5,8,1,6,9]
for(let i = 0; i < arr.length - 1; i++) {
    for (let j = 0 ; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1] && j + 1 < arr.length - 1 - i) {
            let temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
console.log('arr:',arr)


// 很长时间后第一次想到的是这样实现的：
let arr = [3,5,8,1,6,9]
// 主要是对相邻的两个数进行比较，然后交换位置
for (let i = arr.length - 1; i >= 0; i--) {
    for(let j = 0; j < i; j++) {
        if (arr[j] > arr[j+1]) {
          // 因为这里是>，所以可以保持稳定性
          // 如果这里是>=，就会破坏稳定性
            let temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp
        }
    }
}
console.log('arr:',arr)
```

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午8.55.53.png" alt="截屏2021-02-28 下午8.55.53" style="zoom:80%;" />

## 3.堆排序：是先把堆排好了再排序还是一边排堆一边排序？？？？？---先构建堆

==不稳定==

注意：大顶堆的构建过程就是==从最后一个`非叶子节点`开始从下往上调整==。

* **最后一个非叶子节点怎么找？？？**
* ==数组长度 / 2  -   1==（如果不是整数就向下取整）
  

规则：在堆中存储数据，子节点必定大于父节点。？？？？？（这应该只是小顶堆的规则）

往堆中添加数据时，为了遵守上面的规则，**一般会把新数据放在最下面一行靠左的位置。**

> https://segmentfault.com/a/1190000015487916?utm_source=tag-newest

![截屏2021-02-28 下午9.14.31](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.14.31.png)

**关键点：堆由数组实现。==对于结点i，其子结点为2i+1与2i+2==**

堆分为：大根堆和小根堆，升序排序采用大根堆，降序排序采用小根堆。

如果是大根堆，则通过调整函数将值最大的节点调整至堆根。

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.17.46.png" alt="截屏2021-02-28 下午9.17.46" style="zoom:88%;" />

```javascript
let arr = [3,5,8,1,6,9]
// 交换两个节点
// A:数组
function swap(A, i, j) {
    let temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
// 将i节点以下的堆整理为大顶堆
function shiftDown(A, i, length) {
    // let temp = A[i]; // 当前父节点
    // 对节点i以下的节点做顺序调整
    for(let j = 2 * i + 1;j < length; j = 2 * j + 1) {
        let temp = A[i];
        if (j+1 <length && A[j] < A[j+1]) {
            j++ // 找到两个孩子中较大的一个，再与父节点比较。
        }
        if (temp < A[j]) {
            swap(A, i, j);
            // 如果父节点小于子节点，交换；否则跳出
            i = j;
        } else {
            break;
        }
    }
}
// 堆排序
function heapSort(A) {
    // 初始化大顶堆，从第一个非叶子节点开始
    for (let i = Math.floor(A.length/2 - 1); i>=0;i--) {
        shiftDown(A, i, A.length);
    }
    // 排序
    for (let i = Math.floor(A.length - 1); i>0;i--){
        // 根节点与最后一个节点交换
        swap(A, 0, i);
        shiftDown(A, 0, i);
        // 最后一个节点已经为当前最大值，不需要再参与比较。所以第三个参数为i。
    }
}
heapSort(arr);
console.log('arr:',arr);
```

很久之后第二次写出来的代码:!!!

```js
let arr = [3,5,8,1,6,9]

// 构建大顶堆
function heapify (length) {
    for(let i = Math.floor(length / 2 - 1); i>=0; i--) {
        while(2*i+1 < length) {
            let currentNodeVal = arr[i];
            let j = 2*i+1;
            if (j+1 < length && arr[j] < arr[j+1]) {
                j++
            }
            if (arr[j] > currentNodeVal) {
                // 交换位置
                let temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i=j;
            } else {
                break;
            }
        }
    }
}
function sort () {
    for(let i = arr.length; i > 0; i--) {
        heapify(i);
        let temp = arr[0];
        arr[0] = arr[i-1];
        arr[i-1] = temp;
    }
}
sort()
console.log('arr:',arr)
```



> https://www.bilibili.com/video/BV1vt4y1y7wR?from=search&seid=16986629492548488118

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.52.31.png" alt="截屏2021-02-28 下午9.52.31" style="zoom:50%;" />

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.54.20.png" alt="截屏2021-02-28 下午9.54.20" style="zoom:50%;" />

==这里的平均时间复杂度不是很清楚！！！！！==

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.55.43.png" alt="截屏2021-02-28 下午9.55.43" style="zoom:50%;" />

**i，2i+1， 2i+2**

![截屏2021-02-28 下午9.08.34](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-02-28 下午9.08.34.png)

## 4.快速排序

`工作原理`：

1. 首先，从数组中选择一个元素，这个元素被称为基准值。（==基准值怎么选？？？？==基本思想：选取第一个或最后一个元素作为基准值。）
2. 接下来找出比基准值小到元素以及比基准值大的元素。得到两个子数组和一个基准值。（分区——partitioning）
3. 接着对子数组进行排序。

![截屏2021-03-05 上午11.17.16](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.17.16.png)

![截屏2021-03-05 上午11.19.30](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.19.30.png)

![截屏2021-03-05 上午11.21.31](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.21.31.png)

**快速排序的时间复杂度计算：**

https://www.bilibili.com/video/BV1WE411E7Lt?from=search&seid=4214825836504992620

![截屏2021-03-05 上午11.37.41](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.37.41.png)

![截屏2021-03-05 上午11.49.32](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.49.32.png)

![截屏2021-03-05 上午11.54.51](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.54.51.png)

这个递推式是怎么得到的？？？？？？
![截屏2021-03-05 上午11.58.32](/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 上午11.58.32.png)

依旧没有解决我的问题！！！！！

这里遇到了瓶颈！！！！

https://www.bilibili.com/video/BV11t411a7e9?from=search&seid=4214825836504992620

26min处开始讲时间复杂度

<img src="/Users/chenmeifang/Library/Application Support/typora-user-images/截屏2021-03-05 下午1.04.56.png" alt="截屏2021-03-05 下午1.04.56" style="zoom:67%;" />

最坏的情况是一共有n层。

```javascript
let arr = [3,5,8,1,6,9]

function quickSort(arr, from, to) {
    let temp = arr[from]; // 基准值
    let i = from;
    let j = to;
    if (from >= to) {
        return // 如果from=to，说明数组里面只有一个元素；如果from>to，不知道是什么情况
    }
    while (i !== j && i < j) {
        while (temp < arr[j] && j > i) {
            // 继续移动j指针
            j--;
        }
        while (temp >= arr[i] && i < j) {
            i++;
        }
        if (i < j) {
            let temp1 = arr[j];
            arr[j] = arr[i];
            arr[i] = temp1; // 交换i和j指向的两个数后，继续试探。
        }
    }
    // 当i=j时，要和基准值交换位置
    arr[from] = arr[i];
    arr[i] = temp
    
    // 继续对基准值两边的数组进行排序
    quickSort(arr, from, i-1);
    quickSort(arr, i + 1, to);
}

quickSort(arr, 0, arr.length - 1)

console.log('arr:',arr)
```

  时间复杂度突然就搞懂了！！！！

第二次写：

```js
let arr = [3,5,8,1,6,9]

function sort (start, end) {
    if (start >= end) {
        return
    }
    let standardVal = arr[start], // 选取标准值
        i = start,
        j = end;
    // j指针开始向后移动，什么时候停止。当遇到一个值（值1）比基准值小
    // i指针开始向前移动，什么时候通知，当遇到一个值（值2）比基准值大
    // 交换值1和值2
    // 继续移动指针。重复上面的操作
    // ...
    // 什么时候可以停止这个重复的过程？当i和j相遇的时候（值3）
    // 停止这个重复的过程后，交换值3和基准值

    // 交换完成后，对两边的数组递归 进行快速排序
    // 什么时候递归终止？？？想不清楚！！！！！！！！当数组中只有一个元素的时候，可以停止
    while(i!==j && i<j){ // i不能比j大
        while(arr[j] > standardVal && j > i) { // 而在这里加等号就不行？？？？？？
            j--;
        }
        while(arr[i] <= standardVal && j > i) { // 为什么这里一定要加等号？？？？？这里要考虑第一个元素就是基准值的问题！！！
            i++;
        }
        if (j > i) {
            let temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    arr[start] = arr[i];
    arr[i] = standardVal
    sort(start, i-1);
    sort(i+1, end);
}
sort(0, arr.length-1)
console.log('arr:',arr)
```

















































