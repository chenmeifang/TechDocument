https://www.bilibili.com/video/BV1P441157wx?t=167&p=2

# 第二节：nodeJS的诞生和简介

Ryan 为了解决Web服务器的高并发性能问题，他认为通过==事件驱动==和==异步I/O==来达成目的是问题的关键

V8引擎是使用C++进行开发的

# 第三节 NodeJs架构分析

NodeJs的高效异步编程很大程度上归功于libuv

libuv为NodeJS提供了一个跨平台：

* ==线程池 Thread pool==
* 事件池 Event pool
* 异步I/O Async I/O

# 第四节 NodeJS与操作系统交换例子

# 第五节 单线程

I/O可以理解为简单的读取数据。左图中，一个线程在处理I/O的时候，CPU是不工作的。等到I/O结束后，才能计算，所以处理I/O的这段时间CPU就白白浪费了，被白白的阻塞掉了。

但是在单线程的工作机制中就不一样

==为什么处理I/O的时候CPU是不工作的？？？？？？？==

# 第六节  非阻塞IO

# 第七节 事件驱动模型

事件驱动/事件循环

nodejs只有一个主线程在执行代码，形成一个执行栈。

在主线程里，它维护了一个事件队列，这是一个先进先出的队列。

 当网络请求或者异步I/O过来的时候，node会把它们放在事件队列中，此时并不会立即执行它们，代码也不会被阻塞掉， 会继续往下走，直到主线程的代码执行完毕。 

然后通过EventLoop——事件循环机制 检查事件队列中有没有要处理的事件。

这个时候分两种情况：

==如果是非I/O任务==，就会亲自处理这个事件，并通过这个事件的回调函数返回到上层调用。

==如果是I/O任务==，他就会从线程池中分配一个线程来处理这个事件。等它处理完成以后，就会把事件的回调函数放到事件队列的尾部，等到再次轮询的时候，主线程就会亲自处理并且通过回调函数返回到上层调用。

==？？？？？node不是单线程吗？为什么这里又出现了线程池的概念啊？？？？？？？？？？==

# 第八节 优缺点和使适用场景

懂了 

计算逻辑非常耗时

node本身是单线程，阻塞程序运行



 

 

















