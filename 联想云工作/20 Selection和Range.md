在在线协同编辑系统中，一般会选择**重写 `Selection` 和 `Range`** 的逻辑，而不是直接依赖浏览器提供的原生 API，这是由于以下原因：

------

### 1. **跨平台兼容性问题**

不同浏览器对 `Selection` 和 `Range` 的实现可能存在不一致之处，例如：

- **行为差异**：某些浏览器在处理嵌套元素或复杂 DOM 时，`Range` 的行为可能不一致。
- **API 支持差异**：某些较老版本的浏览器对部分 API 的支持有限或存在 bug。

**解决办法**：通过重写，可以抽象出统一的行为，屏蔽浏览器之间的差异。

------

### 2. **逻辑抽象与复杂性管理**

浏览器的 `Selection` 和 `Range` 是针对**单用户操作**设计的，在协同编辑场景下，系统需要管理多个用户的光标和选区，原生 API 无法直接满足以下需求：

- **多用户光标显示**：需要为每个用户分别维护光标和选区状态，并显示在文档中。
- **远程同步**：需要将本地用户的选区状态序列化并同步到远程用户。
- **多选区支持**：某些协作需求可能需要同时管理多个选区，原生 API 不支持。

**解决办法**：重写逻辑，创建适配多用户场景的抽象层，例如通过虚拟光标、虚拟选区等机制实现。

------

### 3. **内容变更追踪**

协同编辑系统通常需要实时捕捉文档内容的变更，以便生成操作日志（如插入、删除等）并同步给其他用户。然而，原生的 `Range` 和 `Selection` 不提供对内容变更的直接感知能力。

**问题**：

- 原生 API 无法跟踪 DOM 的动态变化（如 `innerHTML` 修改后选区失效）。
- 操作范围可能跨越多个节点，原生 `Range` 不易操作和序列化。

**解决办法**：重写 `Selection` 和 `Range`，实现对内容变更的细粒度追踪，并与操作日志结合。

------

### 4. **性能优化**

协同编辑系统需要在高频率的用户操作（如输入、删除、选区变更）中保持流畅的用户体验，直接使用原生 `Selection` 和 `Range` 可能会带来性能瓶颈：

- **频繁操作 DOM**：原生 API 直接操作 DOM，可能导致过多的重排和重绘。
- **冗余调用**：某些 API 调用会触发不必要的事件（如 `selectionchange`），降低性能。

**解决办法**：通过重写，利用虚拟 DOM 或轻量化数据结构来优化性能，并减少实际 DOM 操作的频率。

------

### 5. **序列化和持久化需求**

协同编辑系统需要将选区状态同步到其他客户端，这需要对 `Selection` 和 `Range` 进行序列化，而原生 API 并不支持直接序列化。

**问题**：

- 无法直接保存或传输选区状态。
- DOM 变更后，原生 `Range` 可能失效，导致数据丢失。

**解决办法**：重写逻辑，将 `Selection` 和 `Range` 的信息（如起始位置、结束位置、所属用户）存储为可序列化的结构，便于同步和恢复。

------

### 6. **协作冲突处理**

在协同编辑场景中，多个用户可能同时修改同一区域的内容，选区和光标状态会因此冲突。例如：

- 用户 A 删除了选区范围内的内容，而用户 B 的光标仍然依赖该选区。
- 文档发生复杂变更时，如何正确地更新光标位置。

**解决办法**：通过重写 `Selection` 和 `Range`，结合操作变更日志和文档状态，动态调整选区和光标的逻辑位置，避免冲突。

------

### 7. **定制化功能需求**

协同编辑系统可能需要提供一些超出浏览器原生能力的功能，例如：

- 高亮特定内容（如用户 A 编辑的内容高亮）。
- 同步不同用户的选区样式和颜色。
- 实现特定的选区规则（如禁止跨越特定节点的选区）。

**解决办法**：通过重写选区逻辑，可以灵活扩展这些功能。

------

### 总结

直接使用浏览器提供的 `Selection` 和 `Range` 虽然简单，但无法满足协同编辑系统的复杂需求，如跨平台兼容性、多用户管理、性能优化、变更追踪等。因此，重写 `Selection` 和 `Range` 是为了更好地适配协同编辑的场景，并实现高性能、可扩展的功能。

如果你正在开发协同编辑系统，可以考虑基于原生 API 构建自己的抽象层，例如：

- 使用字符索引（offset）而非 DOM 节点作为选区的基础。
- 基于操作变更日志实时调整选区状态。
- 将逻辑与呈现分离（虚拟选区与实际光标同步）。