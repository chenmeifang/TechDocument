https://www.bilibili.com/video/BV1M44y1R76m/?spm_id_from=333.999.0.0&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

# 1.JS内存管理和闭包的概述

# 2.内存管理的理解

1min47秒处



# 3.GC算法-引用计数

# 4.V8的GC实现的算法

![image-20240221234836310](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240221234836310.png)

10min处

# 面试题：V8垃圾回收机制

V8是一个开源的JavaScript引擎

# 闭包底层

闭包在语言的底层方面到底是怎么实现的？？

JavaScript拥有自动的垃圾回收机制

关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。

==函数的执行上下文在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用==。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。

---

# 书：你不知道的JavaScript



# 第一章：作用域是什么

## 1.1 编译原理

传统编译语言，程序中的一段源代码在执行之前会经历三个步骤，统称为编译：

1. 分词/词法分析;
2. 解析/语法解析；
3. 代码生成；

比起那些编译过程只有三个步骤的语言的编译器，JavaScript引擎要复杂的多。

## 1.2 理解作用域

* 引擎：从头到尾负责整个JS程序的编译及执行过程
* 编译器：负责语法分析及代码生成
* 作用域

```js
var a = 2;
```

* ==编译器==首先将这段程序分解成==语法单元==，然后将词法单元解析成一个==树结构==。
* 编译器遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a
* 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量（查看 1.3 节）。 

==总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值==

## 1.3 作用域嵌套

## 1.4 异常

为什么区分 LHS 和 RHS 是一件重要的事情？ 

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。

# 第二章：词法作用域

## 2.1 词法阶段

## 2.2 欺骗词法

# 第三章：函数作用域和块作用域

## 3.1 函数中的作用域

## 3.2 隐藏内部实现

## 3.3 函数作用域

## 3.4 块作用域

## 3.5 总结

# 第五章：作用域闭包

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包

==当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。==

```js
function foo() {
	var a = 2;
	function bar() { 
    console.log( a ); // 2 
  }
  bar(); 
}
foo();
```

==无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。==































