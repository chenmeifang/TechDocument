# [1. JS内存管理和闭包的概述](https://www.bilibili.com/video/BV1M44y1R76m/?spm_id_from=333.999.0.0&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

![image-20240829094940879](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829094940879.png)

# [2. JS内存管理-内存管理的理解](https://www.bilibili.com/video/BV1M44y1R76m/?p=2&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

![image-20240829095642631](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829095642631.png)



![image-20240829095814050](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829095814050.png)

# [3. JS内存管理-GC算法-引用计数](https://www.bilibili.com/video/BV1M44y1R76m/?p=3&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

Garbage Collection

![image-20240829101819756](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829101819756.png)

![image-20240829102256653](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829102256653.png)

![image-20240829102449297](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829102449297.png)

# [4. JS内存管理-V8的GC实现的算法](https://www.bilibili.com/video/BV1M44y1R76m/?p=4&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

Garbage Collection

![image-20240829105841999](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829105841999.png)

从数据结构的角度来讲，上图是一个图结构

![image-20240829112032780](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829112032780.png)

![image-20240829111532782](10 内存管理(V8垃圾回收机制)和闭包.assets/image-20240829111532782.png)

# 5. 面试题——V8引擎垃圾回收机制

V8是一个开源的JavaScript引擎

V8引擎的垃圾回收机制是通过一套高效的内存管理策略实现的

## 1. 新生代和老生代的内存划分

V8将堆内存分为两个区域：**新生代**和**老生代**

- **新生代**：存储的是生命周期较短的对象，如局部函数和函数作用域中的对象。新生代一般容量较小，因为这些对象大多“短命”
- **老生代**：存储生命周期较长或一直存在的对象，如全局变量，闭包中的对象。老生代的容量通常比新生代大得多

## 2. 新生代的垃圾回收机制——Scavenge算法

- Scavenge算法又被称为复制算法
- 新生代内存划分为两个相等的半区：**From空间**和**To空间**
- 分配对象时，V8只在From空间中进行操作，而To空间则为空
- 触发垃圾回收时，V8将From空间中还存活的对象复制到To空间，而非存活对象会被回收
- 最后From和To空间互换，完成回收

优点：复制算法效率高，不会产生内存碎片？？？

缺点：由于需要两个半区，空间利用率较小，一般新生代区比较小

## 3. 老生代的垃圾回收机制——Mark-Sweep和Mark-Compact算法

对于老生代区域，由于对象生命周期长且数量多，V8使用了更复杂的Mark-Sweep和Mark-Compact算法

- **Mark-Sweep（标记-清除）**：首先标记出存活的对象，然后直接清除未标记的对象
  - 优点：无需额外分配内存，内存使用率高
  - 缺点：会产生内存碎片
- **Mark-Compact（标记-整理）**：在标记存活对象后，将存活对象压缩到内存的一端，之后再清除未使用的内存
  - 优点：避免了内存碎片问题
  - 缺点：由于需要对象移动，相对而言比Mark-Sweep更耗时

# 6. 堆内存

- 堆内存是一种用于**动态分配**和**存储对象**的内存区域。用于管理复杂数据结构，这些数据结构的大小和内容在运行时可能发生变化
- 堆内存主要用于存储对象和数组等复杂数据类型，而基本数据类型（如Number，String等）通常存储在栈内存中
- 堆内存中的数据不像栈内存那样按顺序排列，而是随机分布，数据的位置不固定
- 在JS中，当一个变量指向堆内存中的对象时，该变量实际上保存的是对象的引用（即对象在堆内存中的地址），并不是对象本身的数据
- JS引擎（如V8）会通过垃圾回收机制自动管理堆内存，定期清理不再被引用的对象，从而释放内存空间                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

# 7. 闭包底层

闭包在语言的底层方面到底是怎么实现的？？

JavaScript拥有自动的垃圾回收机制

关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。

=函数的执行上下文在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。
