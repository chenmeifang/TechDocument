# [0. 浏览器输入url后发生了什么](https://www.bilibili.com/video/BV1s44y117vK/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

> url：统一资源定位符 Uniform Resource Locator

1. `DNS解析域名`：把URL地址解析为IP地址

   - 首先，操作系统会检查浏览器缓存和本地的hosts文件中是否有这个网址记录

   <img src="13 浏览器运作原理和重排重绘.assets/image-20240823124452023.png" alt="image-20240823124452023" style="zoom:50%;" />

2. `通过TCP三次握手建立TCP连接`：在发送数据之前建立通道

3. `发送HTTP或HTTPS请求`

4. `响应HTTP或HTTPS请求`

5. `浏览器解析渲染页面`

6. `HTTP请求结束，TCP四次挥手断开TCP连接`

# 0. 在浏览器地址栏输入url后发生的事情

在浏览器地址栏首次输入 URL 并按下 Enter 键后，浏览器会执行一系列步骤来加载网页。以下是这些步骤的详细说明：

### 1. **URL 解析**

- **解析 URL**: 浏览器首先解析输入的 URL，分解为协议（如 `http`、`https`）、主机名（如 `www.example.com`）、端口（如果有的话）、路径（如 `/index.html`）和查询参数（如 `?search=term`）。

### 2. **检查缓存**

- **查找缓存**: 浏览器检查本地缓存，看是否已有该 URL 对应的资源（如 HTML 文件、图片、CSS 文件等）。如果缓存中有匹配的资源，浏览器可以直接使用它来提高加载速度。

### 3. **DNS 解析**

- **DNS 查询**: 如果缓存中没有匹配的资源，**浏览器会查询 DNS 服务器将域名解析为 IP 地址**。这包括以下步骤：
  - **本地缓存**: 浏览器检查操作系统和浏览器的本地 DNS 缓存。
  - **DNS 解析**: 如果本地缓存中没有 IP 地址，浏览器会向 DNS 服务器发起查询，可能涉及多个 DNS 服务器，直到找到正确的 IP 地址。

### 4. **建立 TCP 连接**

- **TCP 三次握手**: 浏览器使用解析到的 IP 地址与目标服务器建立 TCP 连接。这个过程包括三次握手（SYN、SYN-ACK、ACK），确保可靠的连接。

### 5. **进行 HTTPS 握手（如果使用 HTTPS）**

- **SSL/TLS 握手**: 如果 URL 使用 HTTPS，浏览器会进行 SSL/TLS 握手，建立安全的加密连接。包括：
  - **协商加密算法**: 服务器和浏览器协商使用的加密算法。
  - **证书验证**: 验证服务器的 SSL/TLS 证书是否有效。

### 6. **发送 HTTP 请求**

- **构造 HTTP 请求**: 浏览器向服务器发送 HTTP 请求，包括请求方法（如 `GET`、`POST`）、请求 URL、请求头（如 `User-Agent`、`Accept`）等。

### 7. **服务器处理请求**

- **服务器响应**: 服务器处理请求并生成响应。响应包含状态码（如 200、404、500）、响应头和响应体（即请求的资源内容）。

### 8. **接收和处理响应**

- **解析响应**: 浏览器接收服务器的响应，解析响应头和响应体。响应体可能是 HTML、CSS、JavaScript、图片等资源。

### 9. **构建和渲染页面**

- **解析 HTML**: 浏览器将 HTML 文档解析为 DOM（文档对象模型）树。
- **解析 CSS**: 浏览器将 CSS 文件解析为 CSSOM（CSS 对象模型）树。
- **构建渲染树**: 将 DOM 和 CSSOM 结合，生成渲染树。
- **布局计算**: 浏览器计算页面中每个元素的位置和尺寸。
- **绘制页面**: 根据布局信息将内容绘制到屏幕上。

### 10. **执行 JavaScript**

- **执行脚本**: 浏览器执行页面中的 JavaScript 代码，这可能会修改 DOM、CSSOM 或触发其他网络请求。

### 11. **处理用户交互**

- **事件处理**: 页面加载完成后，浏览器会处理用户的交互（如点击、滚动、输入等）。

### 总结

从首次输入 URL 到网页在浏览器中显示，经历了 URL 解析、DNS 查询、TCP 连接、HTTPS 握手（如适用）、HTTP 请求和响应处理、页面渲染和 JavaScript 执行等步骤。每个步骤都是现代网页浏览器为了确保快速、安全和可靠地加载网页而精心设计的。

# [1. 互联网是如何运作的](https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.0&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

| 1. 当电脑连入互联网，电脑会获得一个编号地址 Internet Protocol address(IP地址) |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="13 浏览器运作原理和重排重绘.assets/image-20240819184923116.png" alt="image-20240819184923116"  /> | ![image-20240819185154589](13 浏览器运作原理和重排重绘.assets/image-20240819185154589.png) |
|                                                              | ![image-20240819185235103](13 浏览器运作原理和重排重绘.assets/image-20240819185235103.png) |
|                                                              |                                                              |
|                                                              |                                                              |

# 2. [浏览器是如何运作的](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.880.my_history.page.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

## 2.1 浏览器的发展史

| <img src="13 浏览器运作原理.assets/image-20240304141402704.png" alt="image-20240304141402704"  /> | 简化的浏览器结构图：<br><img src="13 浏览器运作原理.assets/image-20240304153542795.png" alt="image-20240304153542795"  /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

## 2.2 用户界面

> 用于展示除标签页窗口之外的其他用户界面内容

## 2.3 浏览器引擎

用于在用户界面和渲染引擎之间传递数据

## 2.4 渲染引擎

> 负责渲染用户请求的页面内容
>
> 渲染引擎是一个浏览器的核心，往往把渲染引擎称为浏览器的内核

| 不同浏览器使用的内核：<br><img src="13 浏览器运作原理.assets/image-20240304160321259.png" alt="image-20240304160321259" style="zoom:80%;" /> | <img src="13 浏览器运作原理.assets/image-20240304160451343.png" alt="image-20240304160451343"  /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

### 2.4.1 网络模块

> 负责网络请求
>

### 2.4.2 JS解析器

> 用于解析和执行JS 
>

## 2.5 数据持久层

> 帮助浏览器存储各种数据，比如cookie等等

# 3. 根据进程功能不同来拆分浏览器

> 浏览器是运行在操作系统上的一个应用程序。
>
> 每个应用程序必须至少启动一个进程来执行其功能。
>
> 每个程序往往需要运行很多任务，进程就会创建一些线程来帮助它去执行这些小的任务

<img src="13 浏览器运作原理和重排重绘.assets/image-20240801083719829.png" alt="image-20240801083719829" style="zoom: 33%;" />



<img src="13 浏览器运作原理和重排重绘.assets/b61cab529fa31301bde290813b4587fc.png" alt="img" style="zoom: 67%;" />

| 1. 浏览器主进程           | 负责控制Chrome浏览器除标签页外的用户界面，包括地址栏，书签，后退和前进按钮<br>负责与浏览器的其他进程协调工作<br>有一个UI线程 | 主要负责界面显示，用户交互，子进程管理，同时提供存储功能     |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2. 网络进程               | 负责发起接受网络请求                                         | 之前是作为一个模块运行在浏览器主进程里面的，现在已独立出来，成为一个单独的进程 |
| 3. GPU进程                | 负责整个浏览器界面的渲染                                     | Chrome刚开始发布的时候是没有GPU进程的。GPU的使用初衷是为了实现3D CSS的效果。只是随后网页，Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求 |
| 4. 插件进程               | 负责控制网站使用的所有插件，例如flash，这里的插件并不是指Chrome市场里面安装的扩展 |                                                              |
| 5. 渲染器进程（渲染进程） | 用来控制显示tab标签内的所有内容<br>渲染器进程的核心任务：把html，css，js，image等资源渲染成用户可以交互的web页面 | 核心任务是将HTML，CSS和JS转换为用户可以与之交互的网页，排版引擎Blink和JS引擎v8都是运行在该进程中。**默认情况下，Chrome会为每个Tab标签创建一个渲染进程**。处于安全考虑，渲染进程都是运行在沙箱模式下。 |
| 6. 缓存进程               |                                                              |                                                              |

## 渲染器进程（多个）

- 每个Tab标签创建一个渲染进程


- 重排和重绘属于这个进程里的知识点

# 4. 在浏览器地址栏里输入内容时，浏览器内部发生的事

| 1. ==浏览器进程==的==UI线程==会捕捉输入内容<br>    若输入是网址，==UI线程==会启动一个==网络线程==来请求DNS进行域名解析，接着开始连接服务器获取数据<br>    若输入不是网址，而是一串关键词，浏览器就知道你是要搜索，就会使用默认配置的搜索引擎来查询 | <img src="13 浏览器运作原理和重排重绘.assets/image-20240801085333230.png" alt="image-20240801085333230" style="zoom:80%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2. 当==网络线程==获取到数据后，会通过safeBrowsing来检查站点是否是恶意站点<br>    若是，则会提示个警告页面，告诉你这个站点有安全问题，浏览器会阻止你的访问，当然你也可以强行继续访问。<br>    safeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全。比如通过查看该站点的IP是否在谷歌的黑名单之内 | <img src="13 浏览器运作原理和重排重绘.assets/image-20240801085508813.png" alt="image-20240801085508813" style="zoom:80%;" /> |
| 3. 当返回数据准备完毕，并且安全校验通过时，==网络线程==会通知==UI线程==我就要准备好了，该你了 | <img src="13 浏览器运作原理和重排重绘.assets/image-20240801085923390.png" alt="image-20240801085923390" style="zoom:80%;" /> |
| 4. ==UI线程==会创建一个==渲染器**进程**==来渲染页面，==浏览器进程==通过IPC管道将数据传递给==渲染器进程==，正式进入渲染流程 | <img src="13 浏览器运作原理和重排重绘.assets/image-20240801090259117.png" alt="image-20240801090259117" style="zoom:80%;" /> |
| 5. ==渲染器进程==接收到的数据是html，==渲染器进程==的==主线程==将html进行解析，构造DOM（文档对象模型）数据结构<br>    html首先经过Tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素。<br>   html代码中往往会引入额外资源，比如图片，CSS，JS脚本等，图片和CSS这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，因为它们不会影响DOM的生成.<br>   但当HTML解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并且执行JS | ![image-20240801091011211](13 浏览器运作原理和重排重绘.assets/image-20240801091011211.png) |
| 6. 在html解析完成后，会获得一个DOM Tree， 但不知道DOM树上的每个节点长什么样子，==渲染器进程的主线程==需要解析CSS，并确定每个DOM节点的计算样式 | ![image-20240801091212779](13 浏览器运作原理和重排重绘.assets/image-20240801091212779.png) |
| 7. 在知道DOM结构和每个节点的样式后，接下来需要知道每个节点需要放在页面上的哪个位置，也就是节点的坐标以及该节点需要占用多大的区域，这个阶段被称为**layout布局**。<br> | ![image-20240801091339321](13 浏览器运作原理和重排重绘.assets/image-20240801091339321.png) |
| 8. ==主线程==通过遍历dom和计算好的样式来生成Layout Tree，Layout Tree上的每个节点都记录了x,y坐标和边框尺寸。<br>    注意：DOM Tree和Layout Tree并不是一一对应的。设置了display：none的节点不会出现在Layout Tree上.<br>    这样还不够，还需要知道以什么样的顺序绘制这个节点 | <img src="13 浏览器运作原理和重排重绘.assets/image-20240801091513511.png" alt="image-20240801091513511" style="zoom:50%;" /> |
| 9. 为了保证在屏幕上展示正确的层级，主线程遍历Layout Tree创建一个绘制记录表（Paint Record），该表记录了绘制的顺序 | ![image-20240801094958035](13 浏览器运作原理和重排重绘.assets/image-20240801094958035.png) |

# [5. 浏览器是如何进行界面渲染的](https://www.bilibili.com/video/BV1LY41197HX/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

<img src="13 浏览器运作原理和重排重绘.assets/image-20240319222757366.png" alt="image-20240319222757366"  />

1. 获取HTML文件并进行解析，生成一颗DOM Tree
2. 解析CSS，生成样式规则（Style Rules）
3. 根据DOM树和样式规则，生成一颗渲染树（Render Tree）、
4. 进行布局（Layout），即为每个节点分配一个在屏幕上应显示的确切坐标位置
5. 进行绘制（Paint），遍历渲染树节点，调用GPU（图形处理器）将元素呈现出来

# [6. 重排（回流reflow），重绘（repaint）](https://www.bilibili.com/video/BV1WP411Z75i/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

> 重绘：某些元素的外观被改变，例如：元素的背景色
>
> 重排（回流reflow）：指部分或整个渲染树需要重新分析，并且节点的尺寸需要重新计算。表现为**重新生成布局，重新排列元素**
>

# 7. 触发重排的条件

任何页面布局和几何属性的改变都会触发重排，比如：

1、页面渲染初始化；

2、添加或删除可见的DOM元素；

3、元素位置的改变，或者使用动画；

4、元素尺寸的改变——宽度，高度，边距，填充，边框；

5、浏览器窗口尺寸的变化——resize事件发生时；

6、内容的改变——比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；

7、读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),　currentStyle(IE))

# [8. 浏览器对重排重绘的优化](https://www.bilibili.com/video/BV1g8411A7Rq/?spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

<img src="13 浏览器运作原理和重排重绘.assets/image-20240801104257945.png" alt="image-20240801104257945" style="zoom:80%;" />

- 所以浏览器会维护1个队列，把所有会引起重排（回流）、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘

| <img src="13 浏览器运作原理和重排重绘.assets/image-20240801105501917.png" alt="image-20240801105501917" style="zoom: 67%;" /> | 结果：直接显示一个400*400的盒子<br>如果想实现结果2中的过渡效果，应该怎么做？<br><img src="13 浏览器运作原理和重排重绘.assets/image-20240801110134421.png" alt="image-20240801110134421" style="zoom:50%;" /> |
| :----------------------------------------------------------: | ------------------------------------------------------------ |

- 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能起不到作用了


- 比如**当你请求向浏览器获取一些样式信息的时候（为了保证获取结果的准确性），就会让浏览器flush队列**。比如以下属性或方法：

  - offsetTop、offsetLeft、offsetWidth、offsetHeight  https://blog.csdn.net/jinxi1112/article/details/90692484 

  - scrollTop、scrollLeft、scrollWidth、scrollHeight https://blog.csdn.net/gang_gang_gang/article/details/4233044 

  - clientTop、clientLeft、clientWidth、clientHeight

  - getComputedStyle()

  - getBoundingClientRect()


# [9. 重排重绘角度，应该如何优化页面渲染的性能](https://www.bilibili.com/video/BV1Jv4y117uf/?spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改，并减少对style样式的请求

- 集中修改样式（这样可以尽可能利用浏览器的优化机制，一次重排重绘就完成渲染）

- 尽量避免在遍历循环中，进行元素offsetTop等样式值的获取操作

- 如果需要创建多个DOM节点，可以使用**DocumentFragment**创建完后一次性的加入document；

  - <img src="13 浏览器运作原理和重排重绘.assets/image-20240319230736993.png" alt="image-20240319230736993"  />

- ~~直接改变元素的className——不要一条一条地修改 DOM 的样式，可以先定义好 css 的 class，然后修改 DOM 的 className~~

- ~~display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排；~~

- ~~使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；~~

- ~~将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素；~~

- // domParent为已渲染节点

  let child1 = document.createElement('div');

  let child2 = document.createElement('div');

  domParent.appendChild(child1);

  child1.appendChild(child2);

  // 上述会导致浏览器重新渲染两次

```javascript
// domParent为已渲染节点
let child1 = document.createElement('div');
let child2 = document.createElement('div');
child1.appendChild(child2);
domParent.appendChild(child1);
// 在child1还没渲染到页面上，把child2加进去，只会渲染一次
```

fontsize改变会引起重排吗？会

Outline改变会引起重排吗？https://www.pianshen.com/article/97421888871/ 为什么outline-width不会引起回流而border-width会引起？

* 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用
* 在浏览器里，当鼠标点击或使用Tab键让一个链接或者一个radio获得焦点的时候，该元素将会被一个轮廓虚线框围绕。这个轮廓虚线框就是 outline
* border 可应用于几乎所有有形的 html 元素，而 outline 是针对链接、表单控件和 ImageMap 等元素设计
* outline 的效果将随元素的 focus 而自动出现，相应的由 blur 而自动消失。这些都是浏览器的默认行为，无需 JavaScript 配合 CSS 来控制
* outline 是不占空间的，不会像 border 那样影响元素的尺寸或者位置，既不会增加额外的 width 或者 height

# 10. 浏览器线程

在 Chrome 浏览器中，每个标签页（Tab）是一个独立的进程，而每个进程又由多个线程组成。这种架构使得不同标签页之间相对独立，提升了浏览器的稳定性和性能。下面是 Chrome 中常见的线程及其对应的功能：

### 1. **主线程（UI 线程）**
   - **负责功能**：
     - 控制页面的整体逻辑和呈现。
     - 处理页面的**HTML 解析**、**CSS 解析**、**DOM 操作**、**事件处理**、**布局计算**以及**页面的渲染**。
     - 处理用户交互事件（例如鼠标点击、键盘输入等）。
     - 执行 JavaScript 代码。
   - **重要性**：
     - 主线程负责页面的大部分逻辑，是整个渲染流程的核心。当主线程阻塞时，页面的响应会变得迟缓或卡顿。

### 2. **渲染线程**
   - **负责功能**：
     - 负责将 HTML、CSS 和 JavaScript 组合起来，生成页面的视觉内容并绘制到屏幕上。
     - 当内容发生变化（例如滚动、用户交互等），渲染线程会重新计算页面的布局和绘制。
   - **重要性**：
     - 渲染线程直接影响页面的视觉表现和流畅度，确保内容以流畅和高效的方式呈现。

### 3. **合成线程**
   - **负责功能**：
     - 在页面的绘制过程中，将不同的绘制层（layer）组合在一起。
     - 当某些元素（例如动画或滚动）不需要重新计算布局时，合成线程能够单独处理这些更新，而不依赖主线程的重新布局和重绘。
     - 提供流畅的页面动画和滚动效果。
   - **重要性**：
     - 合成线程能够减少主线程的压力，并提高页面的滚动和动画的流畅度，特别是在复杂的网页中。

### 4. **工作线程（Worker Thread）**
   - **负责功能**：
     - 独立于主线程，专门用于执行耗时任务，如复杂计算或数据处理。
     - Service Workers 或 Web Workers 可以在后台执行 JavaScript 代码而不阻塞主线程。
   - **重要性**：
     - 工作线程用于分担主线程的计算负载，避免页面因为复杂运算而卡顿。适合处理并发任务。

### 5. **网络线程**
   - **负责功能**：
     - 处理所有与网络请求相关的任务，如**HTTP 请求**、**WebSocket 连接**等。
     - 接受和发送网络数据。
     - 将网络响应结果发送回主线程进行进一步处理。
   - **重要性**：
     - 网络线程负责与服务器的通信，确保资源的加载速度和数据传输的高效性。

### 6. **存储线程**
   - **负责功能**：
     - 管理数据存储操作，如**LocalStorage**、**IndexedDB**、**Cookie**等。
     - 处理对持久化数据的读写操作。
   - **重要性**：
     - 存储线程确保浏览器能够高效管理和访问持久化的数据资源，而不干扰主线程的执行。

### 7. **GPU 线程**
   - **负责功能**：
     - 将需要硬件加速的渲染任务交给 GPU 处理，例如图形绘制和视频解码。
     - 渲染页面的 3D 动画、Canvas、WebGL 以及视频元素等内容。
   - **重要性**：
     - GPU 线程通过硬件加速提高了渲染效率，使得复杂的图形处理和动画更为流畅。

### 8. **音频线程**
   - **负责功能**：
     - 处理所有与音频播放相关的操作，如背景音乐、视频中的音频播放等。
     - 负责 Web Audio API 的音频流管理和处理。
   - **重要性**：
     - 音频线程独立处理音频，使得音频播放流畅，不受页面主线程或渲染线程的影响。

### 9. **插件线程**
   - **负责功能**：
     - 管理浏览器中安装的插件（如 Flash 等）的运行和处理。
     - 确保插件的执行不会影响浏览器的其他进程或线程。
   - **重要性**：
     - 插件线程独立于主线程运行，确保插件崩溃不会导致整个浏览器标签页崩溃。

### 10. **服务线程**
   - **负责功能**：
     - 处理后台任务和异步任务，如 Service Worker 缓存操作。
     - 管理 Push 通知、后台同步等操作。
   - **重要性**：
     - 服务线程能有效支持页面离线和后台功能，保证浏览器性能。

通过这些多线程的分工，Chrome 浏览器能够在处理复杂页面时保持较高的效率、稳定性和响应速度。每个线程独立负责各自的任务，有助于减少线程间的竞争和瓶颈。

# [11. 浏览器工作原理与实践](https://zhqwq.github.io/broswer-working-principle/guide/intro.html)

https://github.com/zhqwq/broswer-working-principle

## 早期的浏览器多进程架构

![img](13 浏览器运作原理和重排重绘.assets/cdc9215e6c6377fc965b7fac8c3ec960.png)

## 目前的浏览器多进程架构

![img](13 浏览器运作原理和重排重绘.assets/b61cab529fa31301bde290813b4587fc.png)





























