https://www.bilibili.com/video/BV1q64y1j7aH/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

# 1. 函数重载

JS中不支持函数重载

> 函数重载：创建多个名称一样，但是参数类型和返回值不同的函数，以便能够达到编写一个函数，实现多种功能的目的

<img src="02 TS进阶.assets/image-20240801133555975.png" alt="image-20240801133555975" style="zoom:50%;" />

疑问：一定需要第三行的代码吗？？？有了第三行为啥还需要第一行和第二行的代码？？？

# 2. 接口继承

<img src="02 TS进阶.assets/image-20240801133732137.png" alt="image-20240801133732137" style="zoom:50%;" />

# 3. 类的修饰符

| <img src="02 TS进阶.assets/image-20240801133825725.png" alt="image-20240801133825725" style="zoom:50%;" /> | <img src="02 TS进阶.assets/image-20240801134319163.png" alt="image-20240801134319163" style="zoom: 50%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

private：只能在当前类的内部去使用

protected：只能在当前类的内部或者子类中进行访问

# 4. 存取器

> 存取器类似于我们在操作时候使用的getter跟setter
>
> 只不多TS中提供了一种单独的设置方式

<img src="02 TS进阶.assets/image-20240801134641406.png" alt="image-20240801134641406" style="zoom:50%;" />

# 5. 抽象类

> 抽象类是我们在使用类的时候比较常见的一种使用形式
>
> 抽象类它是用来作为子类基类去使用的

<img src="02 TS进阶.assets/image-20240801135201258.png" alt="image-20240801135201258" style="zoom:50%;" />

对于Animal来说，它本身不具备一个实例化的的需求

可以理解为它就是用来去规范格式的

这种类就非常适合作为抽象类来设置

# 6. 类实现接口

> 通过interface来定义类应该具有的行为

| <img src="02 TS进阶.assets/image-20240801135514847.png" alt="image-20240801135514847" style="zoom:50%;" /> | <img src="02 TS进阶.assets/image-20240801135638045.png" alt="image-20240801135638045" style="zoom:50%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

注意：这里不是继承，因为类不可能继承自一个接口。接口本身是没有功能的。叫做实现。

# 7. 泛型类

<img src="02 TS进阶.assets/image-20240801140149656.png" alt="image-20240801140149656" style="zoom:67%;" />

![image-20240801140218416](02 TS进阶.assets/image-20240801140218416.png)

# 8. 泛型

> 泛型允许在定义函数、类或接口时不指定具体的类型，而是使用占位符，等到实际使用时再指定具体类型

# [9. any和unknown的区别](https://www.bilibili.com/video/BV1Bj411V7MV/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

## 赋值时候的表现

1. 任意类型可以赋值给any

   ```typescript
   let p1: any = 47;
   let p2: any = 'Hello';
   let p3: any = {}
   // ...
   ```

2. any也可以赋值给任意类型

   ```typescript
   let p: any = 47;
   let num: number = p;
   let str: string = p;
   let obj: object = p;
   // ...
   ```

3. 任意类型可以赋值给unknown

   ```ts
   let p1: unknown = 47;
   let p2: unknown = 'Hello';
   let p3: unknown = {};
   // ...
   ```

4. 但unknown只能给unknown或any类型赋值

   ```typescript
   let p: unknown = 47;
   let x: unknown = p;
   let y: any = p;
   let num: number = p; // 报错: Type 'unknown' is not assignable to type 'number'.ts(2322)
   let str: string = p; // 报错：Type 'unknown' is not assignable to type 'string'.ts(2322)
   // ...
   ```

## 安全性方面比较

unknown是更加安全的any类型，一般要配合类型检查和类型断言才能对其操作，否则在编译阶段就会报错。

# 10. any和unknown的区别

在 TypeScript 中，`unknown` 和 `any` 是两种不同的类型，它们在类型安全和代码的可预测性方面有着不同的作用。以下是两者的区别：

### 1. **`any` 类型**

- **描述**：`any` 类型可以表示任意类型的值。使用 `any` 的变量可以赋值为任意类型，并且在访问该变量的属性或调用方法时不会进行类型检查。
- **优点**：可以方便地绕过类型检查，使代码更加灵活。
- **缺点**：丧失了类型安全，因为 TypeScript 无法知道这个值的类型，编译时不会提示类型错误。

**示例**：
```typescript
let value: any;
value = 42;
value = "hello";
value = true;

console.log(value.toUpperCase()); // 没有类型检查，可能导致运行时错误
```

在上面的代码中，`value` 变量可以随意更改类型，并且 TypeScript 编译器不会进行任何检查。这虽然灵活，但可能会导致错误的代码无法被及时发现。

### 2. **`unknown` 类型**

- **描述**：`unknown` 类型也可以表示任意类型的值，但与 `any` 不同的是，`unknown` 类型在未进行类型检查或类型断言之前不能进行任何操作。这意味着你必须先检查或确定类型，然后才能使用它。
- **优点**：提供了更高的类型安全性。使用 `unknown` 可以确保在操作前进行适当的类型检查。
- **缺点**：需要额外的类型检查步骤，代码可能略显繁琐。

**示例**：
```typescript
let value: unknown;
value = 42;
value = "hello";
value = true;

// 需要先进行类型检查或类型断言，才能使用它
if (typeof value === "string") {
    console.log(value.toUpperCase()); // 只有在确定是 string 时才能调用 toUpperCase 方法
}

// 或者通过类型断言
console.log((value as string).toUpperCase()); // 如果你确定类型，可以使用类型断言
```

在这个例子中，`value` 是 `unknown` 类型，在使用它之前，必须先通过 `typeof` 检查它是否是 `string` 类型，或者通过类型断言将它转换为 `string` 类型。

### 3. **总结**

- **`any`**：使用 `any` 时，类型检查器完全跳过该变量的类型检查，使代码灵活但容易出错。
- **`unknown`**：使用 `unknown` 时，类型检查器会强制要求你在使用该变量前进行类型检查或类型断言，这提供了额外的安全性。

通常，`unknown` 被认为是 `any` 的一种更安全的替代方案，因为它鼓励你在操作之前明确地处理类型。











var length = 10;



function fn() {

  *return* *this*.length + 1;

}



var obj1 = {

  length: 5,



  test1: function () {

​    *return* fn();

  },

};



const a = obj1.test1.call();

console.log("a:" + a);

const b = obj1.test1();

console.log("b:" + b);



obj1.test2 = fn;

const c = obj1.test2.call();

console.log("c:" + c);

const d = obj1.test2();

console.log("d:" + d);



- 字母数字间隔排开，但不破坏字母顺序和数字顺序
- "abc12d3456ef789gh" -> "a1b2c3d4e5f6g7h89"