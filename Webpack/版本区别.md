# [Webpack4与Webpack5的区别](https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/)

webpack4： 2018年2月

webpack5：2020年10月

Webpack 是一个流行的模块打包工具，用于打包 JavaScript 应用程序的资源。Webpack 5 是 Webpack 4 的后继版本，它引入了一些显著的改进和变化。以下是 Webpack 4 与 Webpack 5 的主要区别：

### 1. **模块联邦（Module Federation）**
   - **Webpack 5**: 引入了模块联邦，这是一个革命性的特性，允许多个独立的应用程序共享代码或依赖项。这使得微前端架构的实现更加容易和高效。
   - **Webpack 4**: 不支持模块联邦，开发者通常需要使用其他方法（如 DLLPlugin 或外部库）来共享模块。

### 2. [持久缓存（Persistent Caching）](#2. 持久缓存)

- **Webpack 5**: 提供了内置的持久缓存功能，通过将缓存存储到文件系统中，显著加快了后续构建的速度。这个功能通过 `cache: { type: 'filesystem' }` 启用。

   - **Webpack 4**: 缓存主要存在于内存中，每次构建时都会重新生成，因此构建速度相对较慢。

### 3. **树摇优化（Tree Shaking）增强**
   - **Webpack 5**: 改进了对未使用代码（dead code）的检测和移除，特别是在使用 ES6 模块时，树摇优化更加智能和高效。
   - **Webpack 4**: 支持树摇优化，但在某些情况下可能不能很好地移除所有未使用的代码。

### 4. **默认 polyfill 行为更改**
   - **Webpack 5**: 不再自动为 Node.js 核心模块（如 `Buffer`、`process`）提供 polyfills，这意味着如果你的项目依赖这些模块，你需要手动添加 polyfill 或者配置 webpack 以启用这些模块。
   - **Webpack 4**: 默认情况下会为 Node.js 核心模块提供 polyfills。

### 5. **Asset Modules**
   - **Webpack 5**: 引入了 Asset Modules，用于处理资源文件（如图像、字体等）。它提供了一个更简单的方式来处理这些文件，而不需要配置特定的 loader（如 file-loader 或 url-loader）。
   - **Webpack 4**: 处理资源文件通常需要配置 `file-loader`、`url-loader` 等插件。

### 6. **分包策略（Code Splitting）优化**
   - **Webpack 5**: 改进了分包策略，默认情况下会生成更少的包，并且包的内容更加合理，减少了重复内容的出现。
   - **Webpack 4**: 分包策略相对较为基础，可能会生成更多的较小的包，且内容重复度较高。

### 7. **移除了 deprecated 的 API**
   - **Webpack 5**: 清除了许多在 Webpack 4 中已经废弃的 API 和配置选项，迫使开发者使用更现代的配置方法，这有助于减少技术债务。
   - **Webpack 4**: 仍然支持一些旧的 API 和配置，尽管这些在未来会被移除。

### 8. **升级的日志和报告工具**
   - **Webpack 5**: 提供了更强大的日志和性能分析工具，帮助开发者更好地理解打包过程和优化构建。
   - **Webpack 4**: 虽然有基本的日志功能，但相对于 Webpack 5 来说，缺乏一些高级的性能分析功能。

### 9. **更好的 WebAssembly 支持**
   - **Webpack 5**: 提供了对 WebAssembly 的增强支持，能够更好地处理和优化 WebAssembly 模块。
   - **Webpack 4**: 支持 WebAssembly，但功能和优化上不如 Webpack 5 完善。

### 10. **减少依赖（Zero-config 默认配置）**
   - **Webpack 5**: 进一步简化了配置，尤其在处理常见的用例时，Webpack 5 的默认配置更加健壮，减少了对外部插件的依赖。
   - **Webpack 4**: 在某些场景下，仍然需要更多的自定义配置和插件来实现特定功能。

### 11. **性能优化**
   - **Webpack 5**: 对许多内部机制进行了重写，以提高构建性能，包括更快的解析和打包速度，尤其在大型项目中表现更为显著。
   - **Webpack 4**: 尽管已经相对优化，但在处理超大规模项目时，性能不如 Webpack 5。

### 总结
Webpack 5 在性能、功能、配置简化等方面做了显著改进，特别是在模块联邦、持久缓存、树摇优化等领域，使其更适合现代的前端开发需求。尽管 Webpack 4 仍然在许多项目中被广泛使用，但升级到 Webpack 5 可以带来显著的构建速度提升和开发体验改善。

# 2. 持久缓存

Webpack 5 中的持久缓存（Persistent Caching）主要设计用于**开发环境**，但在某些情况下，也可以在生产环境中使用

### 1. **开发环境中的持久缓存**

在开发环境中，持久缓存的主要目的是加快后续构建的速度，提高开发效率。由于开发过程中文件频繁变化，Webpack 需要频繁地重新编译代码。持久缓存能够**显著减少每次重新编译的时间**，提升开发体验。

#### **开发环境的优势**:
   - **加快后续构建**: 持久缓存会将编译结果存储在文件系统中。后续构建时，Webpack 可以直接读取未改变模块的缓存，而无需重新编译这些模块，极大地缩短了构建时间。
     - （难道之前的构建方式下，Webpack不能读取webpack未改变模块的缓存吗？？？？？？？？？？难道之前每次构建会重新编译所有模块吗？？？）

   - **减少冗余工作**: 在频繁修改代码的情况下，持久缓存可以减少重复编译的开销，让开发者在保存代码后更快看到结果。
   - **自动处理缓存失效**: Webpack 5 会根据文件内容和依赖关系自动判断缓存是否失效。如果某些文件发生变化，Webpack 会自动重新编译这些文件，并更新缓存。

#### **配置示例**:
   ```javascript
   // webpack.config.js
   module.exports = {
     mode: 'development',
     cache: {
       type: 'filesystem',
       cacheDirectory: path.resolve(__dirname, '.temp_cache'), // 自定义缓存目录
       buildDependencies: {
         config: [__filename], // 当配置文件变化时，重新生成缓存
       },
     },
   };
   ```

### 2. **生产环境中的持久缓存**

在生产环境中，Webpack 的主要目标是生成优化后的、适合发布的静态资源。持久缓存在生产环境中的使用要更为谨慎，因为生产环境通常要求代码的确定性和一致性。

#### **生产环境的考虑**:
   - **构建一致性**: 生产环境的构建通常要求每次构建结果完全一致，而持久缓存可能会在某些情况下导致缓存内容与预期构建结果不一致。因此，生产环境中的缓存需要仔细管理和验证。
   - **构建速度提升**: 对于频繁构建的持续集成（CI/CD）流程，持久缓存也可以用于减少构建时间。但需要确保每次构建前清理旧的缓存，或者确保缓存的正确性。
   - **磁盘空间占用**: 在生产环境中，持久缓存可能占用大量磁盘空间，需要定期清理或者设置合适的缓存策略。

#### **在生产环境使用的场景**:
   - **CI/CD 流程**: 如果生产环境中有频繁的构建需求（如每次代码提交都会触发构建），持久缓存可以帮助减少构建时间。不过在这种情况下，通常需要针对缓存进行严格管理，确保构建的一致性。
   - **构建时间优化**: 对于大型项目，生产环境的构建时间可能较长，使用持久缓存可以在一定程度上减轻这一问题，但要确保缓存的有效性。

#### **配置示例**:
   ```javascript
   // webpack.config.js
   module.exports = {
     mode: 'production',
     cache: {
       type: 'filesystem',
       cacheDirectory: path.resolve(__dirname, 'prod_cache'), // 生产环境的缓存目录
       compression: 'gzip', // 启用缓存压缩以节省空间
       buildDependencies: {
         config: [__filename], // 当配置文件变化时，重新生成缓存
       },
     },
   };
   ```

### 3. **总结**

- **开发环境**: 持久缓存主要设计用于开发环境，通过减少重复编译的开销，显著提升构建速度和开发效率。它可以安全地存储到文件系统中，并在开发过程中自动更新和管理缓存。

- **生产环境**: 持久缓存在生产环境中的使用需更为谨慎。虽然它可以减少构建时间，但要确保构建的一致性和稳定性。它适合频繁构建的 CI/CD 流程，但需要注意缓存管理，以防止缓存导致的不一致问题。

通常情况下，持久缓存是开发环境中的默认选择，而在生产环境中则视项目需求和 CI/CD 流程而定。

# 3. webpack4 dev环境 构建结果的存放位置

webpack4 dev环境 的构建结果是在浏览器内存中还是电脑内存中？？？？

在使用 Webpack 4 的开发环境中，通常会使用 `webpack-dev-server` 来启动一个本地服务器。`webpack-dev-server` 的主要作用是在开发过程中实时构建项目，并在浏览器中自动刷新页面。它的工作方式与构建结果的存储位置相关。

### 1. 构建结果的位置
在 `webpack-dev-server` 启动时，构建出来的结果是存储在**内存中**，而不是写入到物理硬盘上。因此，构建结果主要存在于以下两个地方：

- **电脑的内存**：Webpack 将构建结果保存在内存中，这样可以加快构建速度，因为不需要将文件写入磁盘。
- **浏览器的内存**：当浏览器加载页面时，Webpack 构建出来的结果会被发送到浏览器，浏览器会将其存储在自己的内存中用于渲染页面。

### 2. 实际操作
- **文件系统的内存（电脑内存）**：Webpack 在开发模式下，将文件保存在一个虚拟的文件系统中，位于电脑的内存里。这个虚拟文件系统是由 `webpack-dev-server` 或类似工具提供的。
- **浏览器的内存**：当网页加载时，Webpack 的输出结果会被浏览器接收并存储在浏览器的内存中用于渲染。

因此，在开发环境中，Webpack 的构建结果首先存储在电脑的内存中，然后再被传送到浏览器，并最终在浏览器的内存中被渲染。

# 4. webpack4 dev环境 每次编译所有模块都重新编译吗？

在 Webpack 4 的开发环境中，并不是每次编译时所有的模块都会重新编译。Webpack 会使用一种叫做“增量编译”（incremental compilation）或者“热模块替换”（Hot Module Replacement, HMR）的技术来提高编译效率。

### 1. **增量编译**
增量编译意味着在开发环境中，Webpack 只会重新编译那些发生了变化的模块，而不是整个项目的所有模块。具体流程如下：

- **初次编译**：当你第一次运行 Webpack 时，所有模块都会被编译并生成最终的输出。
- **后续编译**：当你修改代码并保存时，Webpack 只会重新编译那些受影响的模块，以及这些模块的依赖关系（如果有）。

这种方式显著加快了开发环境中的编译速度，因为大多数时候只有少量模块需要重新编译。

### 2. **热模块替换（HMR）**
如果你启用了热模块替换（HMR），Webpack 可以在不刷新整个页面的情况下，只替换更新的模块。这进一步减少了编译和刷新时间，提高了开发效率。

- **局部更新**：当某个模块发生变化时，Webpack 通过 HMR 机制只更新这个模块，其他模块保持不变。页面不会完全刷新，只是应用了变化的部分。
- **保留状态**：HMR 还能保留页面状态，不像全局刷新那样会丢失页面状态（如表单数据、滚动位置等）。

### 3. **优化选项**
在 Webpack 4 中，默认情况下开发模式是优化过的，不会执行所有模块的完全重新编译。但是你可以通过配置进一步控制这种行为，比如使用 `cache` 和 `watchOptions` 配置来管理文件监听和缓存策略。

### 总结
在 Webpack 4 的开发环境中，每次编译并不是所有的模块都会重新编译。Webpack 会根据你的代码变化只重新编译受影响的模块，这样可以显著提高编译速度并提升开发体验。

# 5. webpack4已有增量编译和HMR，为什么还在webpack5中增加持久缓存？

它们的效果难道不是一样的吗？？？

在 Webpack 4 中确实引入了增量编译和热模块替换（HMR），这些技术提高了开发环境中的构建速度。然而，Webpack 5 中引入的持久缓存（persistent caching）是为了解决不同场景下的性能问题，并且与增量编译和 HMR 有着不同的目的和作用。

### 1. **增量编译和 HMR 在 Webpack 4 的局限性**
- **增量编译**：增量编译的确能够在开发环境中加快编译速度，但它的效果通常局限于一次开发会话（session）。也就是说，当你重新启动开发服务器时，所有模块都会被重新编译，即使它们没有变化。**增量编译无法跨会话地保持编译状态**。
  
- **热模块替换（HMR）**：HMR 能够在开发过程中局部更新代码而不刷新整个页面，从而保留应用状态。但是，HMR 仍然依赖于每次启动时的初始编译。HMR 不能减少初始编译的时间，也无法在构建整个项目时提供优化。

### 2. **持久缓存在 Webpack 5 的优势**
Webpack 5 引入的持久缓存通过将编译信息和构建结果持久化到磁盘上，进一步优化了构建性能。其主要优势包括：

- **跨会话加速**：**持久缓存能够在不同的开发会话之间共享缓存**。也就是说，即使你关闭了开发服务器，下次重新启动时，Webpack 也可以利用之前的缓存，大幅减少初始编译时间。

- **生产环境加速**：持久缓存不仅在开发环境中有用，在生产环境下也能显著减少构建时间。因为构建结果已经缓存到磁盘，Webpack 可以跳过对未修改模块的编译。

- **避免重复工作**：持久缓存能避免重复编译那些未改变的模块，减少 CPU 资源的浪费，尤其是在大型项目中，效果尤为显著。

### 3. **两者的区别**
- **增量编译和 HMR** 主要优化的是单次开发会话中的构建速度，减少你在开发过程中等待编译完成的时间。
  
- **持久缓存** 则跨越多个会话，减少每次启动时的初始编译时间，并且能够在生产构建中发挥作用。

### 总结
增量编译和 HMR 提供了实时的开发体验优化，但它们的效果仅限于当前会话。持久缓存则是在 Webpack 5 中增加的一项新特性，旨在跨会话和跨环境（开发和生产）地优化构建性能。它们的效果互为补充，并不是完全一样的。持久缓存显著减少了重新启动开发服务器或进行生产构建时的等待时间，使得整个开发流程更加高效



















