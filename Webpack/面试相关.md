# 1 webpack是如何做性能优化


## 1.1 开发环境

1. 优化代码调试: source-map
2. 优化打包速度: HMR Hot module replacement

## 2.1 生产环境

1. 优化打包体积
2. 优化打包速度：oneOf——提升构建速度；对babel进行缓存；
3. 优化代码调试: source-map
4. 优化线上运行速度：使用hash对资源进行缓存

# 2 tree-shaking的用途，原理

## 2.1 原理

- 基于ES2015模块的**静态解析特性**。
- 当使用**ES2015模块语法**时，可以在代码中使用import和export关键字来申明依赖关系。
- 这些依赖关系可以被静态分析，以确定哪些代码被使用，哪些代码未被使用。
- 基于此，可以删除未使用的代码。
- 在实际应用中，需要使用Tree-shaking技术的构建工具，如Webpack，Rollup等。
- 这些工具可以依据依赖关系构建依赖图，然后使用Tree-Shaking算法来删除未使用的代码，最终生成精简的代码包。





# 3 用过哪些loader

https://juejin.cn/post/6844904094281236487

- **`babel-loader`**：将代码中的es6+语法转换为es5语法，以便在旧版浏览器中运行

- **`ts-loader`**：将TypeScript转换成Javascript，在内部是调用了TypeScript的官方编译器-tsc。所以ts-loader和tsc是共享tsconfig.json

  - 浏览器能识别TS吗？为什么要运行`tsc xxx.ts`命令（即运行TypeScript编译器），去生成js文件

  - ```html
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
      </head>
      <body></body>
      <script src="./index.js"></script>
      <script src="./index2.ts"></script>
    </html>
    ```

  - html中引入ts文件会报错：`Refused to execute script from 'http://127.0.0.1:5500/TypeScript/TypeScriptCode/index2.ts' because its MIME type ('video/mp2t') is not executable.`

- **`css-loader`**：将css文件编译成[**commonjs模块**](E:\TechDocument\js模块化\01.md)，加载到js中，里面内容是样式字符串

- **`style-loader`**：创建style标签，将js中的css样式资源插入进去，添加到页面head中生效

# 4 用过哪些plugin

https://juejin.cn/post/6844904094281236487

# 5 Loader和Plugin的区别

https://juejin.cn/post/6844904094281236487

- `Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作
- 插件接口允许用户直接介入编译过程。 插件可以在不同时期运行的生命周期挂钩上注册回调函数。 在单个编译流程中，当每个钩子都被执行后，插件将拥有 当前编译流程的完整访问权限

# 6 Webpack构建流程

https://juejin.cn/post/6844904094281236487

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

- `初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- `确定入口`：根据配置中的 entry 找出所有的入口文件
- `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

简单说

- 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler
- 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中

对源码感兴趣的同学可以移步我的另一篇专栏[从源码窥探Webpack4.x原理](https://juejin.cn/post/6844904046294204429)

# 7. Webpack构建流程

> compiler对象：保存了完整的webpack环境配置，通过compiler.option可以访问loaders,entry,output,plugin等等完整的配置信息
>
> 怎么加载那些插件？

| 1. **初始化阶段（Initialization）**：<br/>   - Webpack从配置文件（如`webpack.config.js`）中读取配置，结合默认配置生成最终的配置对象。<br/>   - 初始化各种插件，实例化Compiler对象，并加载所有插件。<br/><br/>2. **编译阶段（Compilation）**：<br/>   - 从入口文件开始，根据配置中的入口点，递归地解析依赖图，构建模块依赖关系图。<br/>   - 每找到一个模块，Webpack会调用相应的Loader去处理该模块，转换为标准的JavaScript模块。<br/>   - 解析完所有模块及其依赖后，生成抽象语法树（AST）。<br/><br/>3. **构建阶段（Building）**：<br/>   - 通过分析AST，Webpack将每个模块及其依赖转化为一个或多个`chunk`（代码块）。<br/>   - `chunk` 是构建的基本单位，包含了实际的模块代码和相关的运行时代码。<br/><br/>4. **优化阶段（Optimization）**：<br/>   - 在这个阶段，Webpack会对生成的代码块进行各种优化，例如代码分割（Code Splitting）、树摇（Tree Shaking）、压缩（Minification）、作用域提升（Scope Hoisting）等。<br/>   - 使用插件进行代码优化，比如UglifyJSPlugin进行压缩、TerserPlugin进行代码混淆等。<br/><br/>5. **输出阶段（Output）**：<br/>   - 将优化后的代码块和资源写入输出文件系统（通常是磁盘）。<br/>   - 根据配置文件中的output字段，生成最终的打包文件，如`bundle.js`。<br/>   - 生成HTML文件、CSS文件、Source Map等辅助文件。<br/><br/> | <img src="原理.assets/image-20240331143655928.png" alt="image-20240331143655928" style="zoom:150%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

### 工作原理

1. **模块化打包**：
   - Webpack将所有类型的资源视为模块，包括JavaScript、CSS、图片、字体等。通过Loader和Plugin系统，Webpack可以处理各种类型的文件，并将它们转换为浏览器可以理解的JavaScript模块。

2. **依赖图**：
   - Webpack通过解析入口文件及其依赖，构建一个模块依赖图。这个依赖图表示应用程序中各模块之间的关系和依赖。

3. **Loader**：
   - Loader是Webpack中用来转换模块的工具。它们可以将非JavaScript文件（如CSS、图片）转换为Webpack可以处理的模块。Loader是一个函数，接受源文件作为参数，并返回转换后的文件内容。

4. **Plugin**：
   - Plugin用于扩展Webpack的功能，它们可以介入Webpack打包流程的各个阶段，执行广泛的任务，如打包优化、资源管理、环境变量注入等。Plugin是一个具有`apply`方法的对象，`apply`方法会在Webpack的不同生命周期钩子中被调用。

5. **热模块替换（HMR）**：
   - Webpack支持热模块替换，可以在不刷新浏览器的情况下替换、添加或删除模块。HMR可以极大地提升开发效率。

### 简单的例子

以下是一个简单的`webpack.config.js`配置文件的例子：

```javascript
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/index.js', // 入口文件
  output: {
    filename: 'bundle.js', // 输出文件名
    path: path.resolve(__dirname, 'dist') // 输出路径
  },
  module: {
    rules: [
      {
        test: /\.js$/, // 处理.js文件
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader', // 使用babel-loader转换ES6代码
          options: {
            presets: ['@babel/preset-env']
          }
        }
      },
      {
        test: /\.css$/, // 处理.css文件
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html' // 使用模板生成最终的HTML文件
    })
  ]
};
```

这个配置文件定义了入口点、输出配置、模块规则（使用Loader处理不同类型的文件）和插件（HtmlWebpackPlugin生成HTML文件）。

# 8. webpack打包生成的html文件没有hash值，如何在每次部署更新请求html时候，不会命中缓存

在部署时，防止 HTML 文件命中缓存的常见做法是通过修改请求的 URL 来实现，而不是直接在文件名中添加哈希值。以下是几种解决方案：

### 1. 通过服务器配置添加缓存控制头
你可以通过服务器配置来控制缓存。添加或修改 `Cache-Control` HTTP 头部，让浏览器不缓存 HTML 文件或设置一个较短的缓存时间。例如：

```bash
Cache-Control: no-cache, no-store, must-revalidate
```

### 2. 在 HTML 文件中添加查询参数
另一种方法是通过在 HTML 文件的 URL 中添加一个动态的查询参数来避免缓存，例如使用构建时间戳或版本号：

```html
<script src="main.js?v=123456"></script>
```

在每次部署时，可以自动生成一个新的版本号或时间戳并附加到 URL 上。

### 3. 使用插件动态修改 HTML 请求
可以使用 Webpack 插件在生成的 HTML 文件中自动添加查询参数。`html-webpack-plugin` 是一种常见的选择：

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      cache: false, // 禁用缓存
    }),
    new webpack.DefinePlugin({
      'process.env.BUILD_TIME': JSON.stringify(new Date().getTime())
    })
  ]
};
```

在你的 HTML 模板中，可以这样使用：

```html
<script src="main.js?v=<%= process.env.BUILD_TIME %>"></script>
```

每次构建时，`BUILD_TIME` 会被替换为当前的时间戳，从而使浏览器每次都请求新的 HTML 文件。

### 4. 在 CI/CD 流水线中实现缓存破坏
在 CI/CD 流水线中，也可以自动化地处理版本号或时间戳的更新，以确保每次部署时 URL 都是唯一的。

这些方法能有效防止浏览器缓存旧的 HTML 文件，从而确保每次部署后用户能够获取最新版本的页面。

# 9. 如何单独只给html文件设置cache-control头部

要单独为 HTML 文件设置 `Cache-Control` 头部，可以在 Koa 后端中使用中间件来实现。以下是一个简单的示例，展示如何为 HTML 文件设置 `Cache-Control` 头部，而不影响其他静态资源的缓存策略。

### 1. 配置 Koa 中间件
在 Koa 中，你可以使用 `koa-static` 来提供静态文件，并配合自定义的中间件来设置 HTML 文件的缓存头。

```javascript
const Koa = require('koa');
const path = require('path');
const serve = require('koa-static');
const app = new Koa();

// 静态文件中间件
app.use(serve(path.join(__dirname, 'public')));

// 自定义中间件：单独为 HTML 文件设置缓存头
app.use(async (ctx, next) => {
  await next();
  
  if (ctx.path.endsWith('.html')) {
    ctx.set('Cache-Control', 'no-cache, no-store, must-revalidate');
  }
});

// 其他中间件或路由
// ...

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

### 2. 项目结构
假设你的 React 应用经过打包后放在 `public` 目录中，Koa 会通过 `koa-static` 提供该目录下的文件，并且中间件会检测请求的路径是否以 `.html` 结尾。如果是，它会为响应添加 `Cache-Control` 头部。

```
project-root/
├── public/
│   ├── index.html
│   ├── main.js
│   └── ...
├── server.js
└── ...
```

### 3. 运行服务器
启动服务器后，访问 HTML 文件时，浏览器会接收到 `Cache-Control: no-cache, no-store, must-revalidate` 头部，确保每次请求都会获取最新的 HTML 文件，而其他静态资源（如 JS、CSS）仍然可以按需缓存。

# 10. 如何对项目进行部署

将前端使用 React 和后端使用 Koa 的项目进行部署，涉及到将前端的静态文件与后端的 API 服务进行集成。以下是详细步骤：

### 1. **打包前端应用**
   首先，你需要将 React 应用打包成静态文件。通常使用 Webpack 或者 `create-react-app` 的打包功能。

   ```bash
   npm run build
   ```

   这将生成一个 `build`（或 `dist`）目录，里面包含了打包后的静态文件。

### 2. **配置 Koa 提供静态文件服务**
   使用 `koa-static` 中间件将前端的静态文件部署在 Koa 服务中。

   - **安装 `koa-static`**
     ```bash
     npm install koa-static
     ```

   - **在 Koa 中配置静态文件服务**
     在你的 Koa 应用中，添加以下代码来提供静态文件服务：

     ```javascript
     const Koa = require('koa');
     const serve = require('koa-static');
     const path = require('path');
     
     const app = new Koa();
     
     // Serve static files from the "build" directory
     const staticPath = path.join(__dirname, 'build');
     app.use(serve(staticPath));
     
     // Handle all other routes and serve index.html
     app.use(async (ctx) => {
         ctx.status = 200;
         ctx.type = 'html';
         ctx.body = require('fs').createReadStream(path.join(staticPath, 'index.html'));
     });
     
     // Start the server
     const port = process.env.PORT || 3000;
     app.listen(port, () => {
         console.log(`Server is running on http://localhost:${port}`);
     });
     ```

   在这个配置中，Koa 会为 `/` 路径下的请求提供 `build` 目录中的静态文件。如果请求的路径不匹配任何静态文件，则会返回 `index.html`，以支持 React 的客户端路由。

### 3. **配置后端 API 路由**
   确保你的 Koa 应用中的 API 路由与静态文件的路由区分开，通常可以使用 `/api` 前缀：

   ```javascript
   const Router = require('koa-router');
   const router = new Router();

   // Example API route
   router.get('/api/hello', (ctx) => {
       ctx.body = { message: 'Hello from Koa API!' };
   });

   app.use(router.routes()).use(router.allowedMethods());
   ```

### 4. **部署到服务器**
   将你的 Koa 应用与打包后的前端应用一起部署到服务器上。可以选择以下几种部署方式：

   - **使用云服务：**
     使用 AWS EC2、DigitalOcean 等服务器，将代码上传并运行 Koa 服务器。

   - **使用 Docker：**
     创建一个 Docker 镜像，将 Koa 应用与前端应用打包在一起，方便在服务器上运行。

   - **使用 PaaS 平台：**
     如 Heroku、Render 等，可以通过它们的 Git 集成进行自动化部署。

### 5. **域名和反向代理**
   使用 NGINX 或 Apache 作为反向代理服务器，将流量转发到你的 Koa 应用。

   - **NGINX 配置示例：**
     
     ```nginx
     server {
         listen 80;
         server_name yourdomain.com;
     
         location / {
             proxy_pass http://localhost:3000;
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection 'upgrade';
             proxy_set_header Host $host;
             proxy_cache_bypass $http_upgrade;
         }
     }
     ```

### 6. **测试部署**
   部署完成后，通过浏览器访问你的域名或服务器IP，测试前端和后端是否正常工作。

### 7. **自动化部署**
   配置 CI/CD（如 GitHub Actions、GitLab CI/CD）以便在代码提交时自动打包和部署。

通过这种方式，你可以将前后端整合部署，并在一个服务器上运行完整的应用程序。

# 11. 在不购买云服务器的前提下，将Koa项目和打包后的react前端项目部署到服务器上

在不购买云服务器的前提下，你可以选择使用免费的或低成本的托管平台、PaaS（平台即服务）、无服务器架构，或者本地服务器来部署你的 Koa 项目和打包后的 React 前端项目。以下是几种具体的方案：

### 1. **使用 Heroku**
Heroku 是一个流行的 PaaS 平台，可以免费托管小型应用。你可以将 Koa 和打包后的 React 项目一起部署到 Heroku 上。

#### 步骤：
1. **准备项目文件**：确保你已经将 React 前端项目打包（生成 `build` 或 `dist` 目录），并将其复制到 Koa 项目的 `public` 目录中。

2. **创建 `Procfile`**：在 Koa 项目的根目录下创建一个名为 `Procfile` 的文件，用于告诉 Heroku 如何启动应用。内容如下：

   ```
   web: node app.js
   ```

3. **初始化 Git 仓库**：

   ```bash
   git init
   git add .
   git commit -m "Initial commit"
   ```

4. **部署到 Heroku**：

   - 安装 [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) 并登录：

     ```bash
     heroku login
     ```

   - 创建一个 Heroku 应用：

     ```bash
     heroku create
     ```

   - 部署应用：

     ```bash
     git push heroku master
     ```

   Heroku 会自动检测并部署你的 Node.js 应用，并在构建后提供一个 URL 供你访问。

### 2. **使用 Render**
Render 是另一个 PaaS 平台，支持静态文件和 Node.js 应用托管，有免费计划。

#### 步骤：
1. **创建 Render 账户**：在 [Render](https://render.com/) 注册一个账户。

2. **连接 GitHub 仓库**：将你的项目推送到 GitHub，然后在 Render 上连接该仓库。

3. **创建 Web 服务**：
   - 在 Render 上创建一个新的 Web 服务，选择你的 GitHub 仓库。
   - 设置构建命令为 `npm install` 和启动命令为 `node app.js`。
   - Render 会自动从你的仓库中拉取代码并部署。

### 3. **使用 Vercel**
Vercel 更适合前端项目，但也可以简单地托管 Node.js 后端。

#### 步骤：
1. **将前端部署到 Vercel**：
   - 你可以直接将 React 项目部署到 Vercel 上，Vercel 会自动处理构建和发布。
   
2. **使用 Serverless Functions 部署 Koa API**：
   - 如果 Koa 项目中的某些路由可以作为无服务器函数运行，可以将这些部分移植到 Vercel Functions 上。
   - 这样，你可以将前端和后端 API 都部署到 Vercel。

### 4. **使用 GitHub Pages 和 Serverless API**
GitHub Pages 允许免费托管静态网站，而后端可以使用无服务器架构来部署。

#### 步骤：
1. **将 React 项目托管到 GitHub Pages**：
   - 使用 `gh-pages` 插件将 React 项目部署到 GitHub Pages。

   ```bash
   npm install --save gh-pages
   ```

   在 `package.json` 中添加以下脚本：

   ```json
   "scripts": {
     "predeploy": "npm run build",
     "deploy": "gh-pages -d build"
   }
   ```

   部署：

   ```bash
   npm run deploy
   ```

2. **部署 Koa API**：
   - 将 Koa 项目中的 API 部署到无服务器平台如 AWS Lambda 或 Vercel Functions。

3. **配置前端访问 API**：
   - 在 React 项目中，使用 AJAX 请求这些 API，确保前端和后端集成。

### 5. **使用本地服务器**
如果你有一台可以长期运行的计算机或服务器，可以在本地部署你的应用，并通过端口转发或动态 DNS 将其公开。

#### 步骤：
1. **配置端口转发**：
   - 在你的路由器上设置端口转发，将外部请求转发到你的本地服务器。

2. **使用动态 DNS**：
   - 使用服务如 No-IP 设置动态 DNS，将你的动态 IP 绑定到一个域名上。

3. **运行 Koa 应用**：
   - 在本地服务器上运行 Koa 应用，并通过公开的域名或 IP 访问。

### 总结
以上方法都不需要购买云服务器，你可以根据自己的需求和项目规模选择合适的部署方式。对于个人或小型项目，Heroku 和 Render 是最简单且有效的选择。如果你希望完全控制自己的服务器，则可以考虑使用本地服务器方案。

# 12. 部署项目到云服务器

将 Koa 项目和打包后的 React 前端项目部署到腾讯云服务器上涉及以下几个步骤。假设你已经购买并配置好一台腾讯云服务器（CVM），以下是部署的具体步骤：

### 1. **准备服务器**
   - **登录腾讯云控制台**：通过 SSH 登录到你的腾讯云服务器。
   - **更新系统和安装 Node.js**：
     ```bash
     sudo apt update
     sudo apt upgrade -y
     ```
   - **安装 Node.js**：
     如果你还没有安装 Node.js，可以使用以下命令安装：
     ```bash
     curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
     sudo apt install -y nodejs
     ```
     检查安装是否成功：
     ```bash
     node -v
     npm -v
     ```

### 2. **上传项目代码**
   - 使用 `scp`、`rsync` 或者直接通过 Git 将你的 Koa 项目上传到服务器。

   示例使用 `scp` 命令：
   ```bash
   scp -r /path/to/your/koa-project user@your-server-ip:/path/to/destination/
   ```

   或者通过 Git 将代码克隆到服务器上：
   ```bash
   git clone https://github.com/yourusername/yourrepository.git
   cd yourrepository
   ```

### 3. **安装项目依赖**
   登录到服务器并进入项目目录，然后安装项目的依赖项：
   ```bash
   cd /path/to/your/project
   npm install
   ```

### 4. **构建 React 前端项目**
   如果你还没有打包 React 项目，可以在服务器上打包：
   ```bash
   cd /path/to/your/react-project
   npm run build
   ```
   打包后，会生成一个 `build`（或 `dist`）目录。

### 5. **配置 Koa 提供静态文件服务**
   将打包后的 React 文件复制到 Koa 项目的 `public` 目录中，然后配置 `koa-static` 中间件来提供静态文件服务：

   ```javascript
   const Koa = require('koa');
   const serve = require('koa-static');
   const path = require('path');
   const Router = require('koa-router');

   const app = new Koa();
   const router = new Router();

   // 提供静态文件服务
   const staticPath = path.join(__dirname, 'public', 'build');
   app.use(serve(staticPath));

   // API 路由配置
   router.get('/api/example', (ctx) => {
       ctx.body = { message: 'Hello from Koa API!' };
   });

   app.use(router.routes()).use(router.allowedMethods());

   // 处理所有非 API 请求并返回 index.html
   app.use(async (ctx) => {
       if (ctx.status === 404 && !ctx.path.startsWith('/api')) {
           ctx.type = 'html';
           ctx.body = require('fs').createReadStream(path.join(staticPath, 'index.html'));
       }
   });

   const port = process.env.PORT || 3000;
   app.listen(port, () => {
       console.log(`Server is running on http://localhost:${port}`);
   });
   ```

### 6. **启动 Koa 服务**
   - 直接运行你的 Koa 应用：
     ```bash
     node app.js
     ```

   - 为了确保服务在重启后仍然运行，建议使用 `pm2` 进行管理：
     ```bash
     npm install -g pm2
     pm2 start app.js
     pm2 save
     pm2 startup
     ```

### 7. **配置防火墙**
   确保你的腾讯云服务器防火墙允许 HTTP 和 HTTPS 端口（通常是 80 和 443）访问。如果你使用的是自定义端口（如 3000），需要在防火墙规则中添加允许访问的条目。

   - 在腾讯云控制台，找到你的实例，进入“安全组”设置，确保开启相应的端口。

### 8. **配置 Nginx 反向代理（可选）**
   如果你希望通过 Nginx 处理 HTTP 请求，并将请求转发给你的 Koa 应用，可以进行以下配置：

   - 安装 Nginx：
     ```bash
     sudo apt install nginx
     ```

   - 配置 Nginx：
     编辑 `/etc/nginx/sites-available/default`，并添加以下配置：
     ```nginx
     server {
         listen 80;
         server_name yourdomain.com;
     
         location / {
             proxy_pass http://localhost:3000;
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection 'upgrade';
             proxy_set_header Host $host;
             proxy_cache_bypass $http_upgrade;
         }
     
         location /api {
             proxy_pass http://localhost:3000;
             proxy_http_version 1.1;
             proxy_set_header Upgrade $http_upgrade;
             proxy_set_header Connection 'upgrade';
             proxy_set_header Host $host;
             proxy_cache_bypass $http_upgrade;
         }
     }
     ```

   - 测试 Nginx 配置并重启服务：
     ```bash
     sudo nginx -t
     sudo systemctl restart nginx
     ```

### 9. **绑定域名（可选）**
   如果你有域名，可以将域名绑定到你的腾讯云服务器的 IP 地址。在域名管理系统中设置 A 记录指向服务器的公网 IP 地址。

### 10. **访问你的应用**
   通过浏览器访问你的域名或服务器 IP 地址，确保应用运行正常。

### 总结
通过以上步骤，你可以将 Koa 项目和打包后的 React 前端项目成功部署到腾讯云服务器上。如果需要处理更多流量或提供更高的可用性，可以考虑使用负载均衡和 CDN 等服务。

# 13. 怎么查看云服务器的IP地址

要查看腾讯云服务器（CVM）的 IP 地址，可以通过以下几种方式：

### 方法 1：通过腾讯云控制台

1. **登录腾讯云控制台：**
   访问 [腾讯云控制台](https://console.cloud.tencent.com/) 并用你的帐户登录。

2. **进入 CVM 实例管理页面：**
   在控制台首页，选择“云服务器 CVM”服务，进入你的云服务器实例列表页面。

3. **查看 IP 地址：**
   在实例列表中，你可以看到每个实例的公网 IP 地址和内网 IP 地址。如果你需要具体的 IP 地址，点击实例名称可以查看更详细的信息。

### 方法 2：通过服务器内部命令

如果你已经登录到腾讯云服务器的终端（例如通过 SSH），可以使用以下命令查看 IP 地址：

- **查看公网 IP 地址（如果配置了）：**
  ```bash
  curl http://ifconfig.me
  ```

- **查看内网 IP 地址：**
  ```bash
  ip addr show
  ```
  或者：
  ```bash
  ifconfig
  ```

### 方法 3：通过 API 查询

如果你需要编程访问或自动化管理，可以使用腾讯云的 API 来查询 IP 地址。你可以使用腾讯云的 [API 文档](https://cloud.tencent.com/document/api/213/17683) 来查找相关接口。

选择最适合你需求的方法来获取 IP 地址。如果你有其他问题或需要进一步的帮助，随时告诉我！

# 14. 部署后报错

```shell
(node:27235) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 close listeners added to [TLSSocket]. Use emitter.setMaxListeners() to increase limit
```

# 15. 项目部署前，前端和后端各有一个源；项目部署后，是使用前端的源还是后端的源

项目部署后，前端和后端的源（即域名或IP地址）通常会统一为一个源，前端的请求会通过这个统一的源访问后端。以下是两种常见的部署方式，以及如何处理源的问题：

### 1. **前端和后端在同一个服务器上**

如果前端和后端都部署在同一个服务器上，且通过同一个域名或IP地址访问，那么最终的源是**后端的源**。在这种情况下，CORS 问题通常不会存在，因为前端和后端是同源的。

- **统一源的例子：**
  - **前端：** `http://example.com`（部署后的前端资源，如 HTML、CSS、JS 等）
  - **后端：** `http://example.com/api`（前端通过这个路径访问后端 API）

- **如何实现：**
  - 使用 Nginx 或其他 Web 服务器将静态资源（前端）和 API 请求（后端）配置在同一个域名下，或者通过反向代理的方式将请求转发到相应的服务。

### 2. **前端和后端分别在不同的服务器上**

如果前端和后端分别部署在不同的服务器或不同的域名下，最终的源将根据你如何访问应用程序来确定。

- **前端源的例子：**
  - **前端：** `http://frontend.example.com`
  - **后端：** `http://api.example.com`（前端请求时，会向这个域发出请求）

- **处理 CORS：**
  - 在这种情况下，后端需要正确配置 CORS，允许前端的源（例如 `http://frontend.example.com`）访问 API。
  - 例如，在 Koa 中配置 CORS：
    ```javascript
    app.use(cors({
      origin: 'http://frontend.example.com',
      credentials: true,
    }));
    ```

### 部署时的常见做法

1. **使用同一个域名：** 前端和后端都使用同一个域名，不同路径来区分。这样可以避免 CORS 问题。
   
2. **使用子域名：** 前端和后端分别使用子域名（如 `frontend.example.com` 和 `api.example.com`），然后通过后端的 CORS 配置允许前端访问。

3. **使用反向代理：** 使用 Nginx 等 Web 服务器配置反向代理，将前端和后端请求都通过同一个域名进行管理。

### 总结

- **项目部署后，一般使用的是后端的源**，通过统一的域名来管理前后端资源，以避免 CORS 问题。
- 如果前后端源不同，需要正确配置 CORS，确保前端可以访问后端资源。

# 16. react项目变成koa的静态文件后，react路由失效

当你将 React 项目打包为静态文件并部署在 Koa 上时，可能会遇到路由失效的问题。这通常是因为 React 使用的是客户端路由（基于 `react-router` 等库），而服务器默认不知道如何处理这些路由。当用户直接访问一个非根路径（如 `/about`）时，服务器会尝试查找 `public/about` 目录或文件，而不是将请求重定向回 `index.html`。

### 解决方案：配置服务器以支持 React 的客户端路由

为了让 Koa 正确处理所有客户端路由，你需要配置服务器，使其在找不到静态文件时默认返回 `index.html`。这可以通过以下步骤实现：

#### 1. **安装 `koa-static` 和 `koa-send`**

首先，确保你安装了 `koa-static` 和 `koa-send` 这两个包，它们分别用于处理静态文件和发送文件。

```bash
npm install koa-static koa-send
```

#### 2. **配置 Koa 以支持 React 路由**

你需要在 Koa 中配置一个中间件，以便在找不到静态文件时返回 `index.html`。

```javascript
const Koa = require('koa');
const path = require('path');
const serve = require('koa-static');
const send = require('koa-send');

const app = new Koa();
const staticPath = path.join(__dirname, 'public'); // 假设静态文件在 public 目录

// 配置静态文件中间件
app.use(serve(staticPath));

// 处理 React 路由
app.use(async (ctx) => {
  // 如果请求的路径不以 /api 开头，且找不到对应的静态文件
  if (ctx.status === 404 && ctx.method === 'GET') {
    await send(ctx, 'index.html', { root: staticPath });
  }
});

// 其他 API 路由和中间件配置
// ...

app.listen(4000, () => {
  console.log('Server is running on http://localhost:4000');
});
```

### 解释

- **`koa-static` 中间件**：用于提供静态文件服务，例如你的 React 项目打包后的文件。
- **`koa-send` 中间件**：当服务器找不到请求的静态文件时，将所有请求重定向到 `index.html`，从而让 React 前端应用处理路由。
- **处理 `/api` 之外的所有路由**：在这个配置中，所有以 `/api` 以外的路径（例如 `/about`、`/contact` 等）将会被重定向到 `index.html`，然后由 React 应用处理这些路由。

### 部署后的访问

- 访问 React 应用的根路径：`http://yourdomain.com/`
- 访问 React 应用的其他路由（如 `/about`）：`http://yourdomain.com/about`，即使页面刷新，服务器也会返回 `index.html`，并由 React 处理该路由。

### 总结

通过将 Koa 配置为在找不到静态文件时返回 `index.html`，你可以解决在部署后 React 客户端路由失效的问题。这种方式确保无论用户直接访问哪个路由，服务器都会返回应用的入口文件 `index.html`，然后由 React 的路由系统接管并渲染相应的页面。

# 17. react项目变成koa的静态文件后，react路由跳转 但是之前的路由内容未消失

当你将 React 项目部署为 Koa 的静态文件后，如果在 React 中进行路由跳转时，发现之前的路由内容没有消失，这可能是因为你的 React 组件没有正确卸载，或者 React Router 没有正确地处理页面的更新。

### 可能的原因及解决方法

#### 1. **React Router 配置问题**

React Router 在处理路由时，如果路由组件没有正确卸载，可能会导致旧的内容和新的内容同时显示。确保你在使用 React Router 时正确配置了 `Switch` 组件，确保在路由切换时，只有一个组件被渲染。

```javascript
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Home from './Home';
import About from './About';

function App() {
  return (
    <Router>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
      </Switch>
    </Router>
  );
}

export default App;
```

`Switch` 组件确保在多个 `Route` 匹配时，只渲染第一个匹配的路由。

#### 2. **组件的 `key` 属性**

在 React 中，`key` 是一个特殊的属性，帮助 React 在更新时识别哪些元素已经改变。如果 `key` 属性没有正确设置，可能会导致组件没有正确卸载。确保你为动态渲染的组件设置了唯一的 `key`。

```javascript
<Route path="/about" component={() => <About key={uniqueKey} />} />
```

`uniqueKey` 应该是一个能唯一标识每个组件实例的值。

#### 3. **组件的生命周期方法**

检查你的组件的生命周期方法（例如 `componentDidMount` 和 `componentWillUnmount`），确保在组件卸载时正确清理了相关的副作用。例如，如果你在组件中设置了定时器、事件监听器等，在组件卸载时需要移除它们。

```javascript
useEffect(() => {
  // 例如，设置事件监听器
  const handleResize = () => {
    console.log('Window resized');
  };
  window.addEventListener('resize', handleResize);

  return () => {
    // 在组件卸载时移除监听器
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

#### 4. **Koa 的缓存配置**

如果你在 Koa 中设置了缓存（例如通过 `koa-static`），可能会导致浏览器没有及时更新页面内容。可以尝试禁用缓存或在开发过程中禁用缓存：

```javascript
app.use(serve(staticPath, {
  maxage: 0, // 禁用缓存
  setHeaders: (res) => {
    res.setHeader('Cache-Control', 'no-store'); // 确保浏览器不缓存资源
  }
}));
```

#### 5. **检查 HTML 模板**

如果你使用的是单页应用程序（SPA），确保你的 `index.html` 文件结构是正确的，确保 `root` 节点没有被多次渲染。

### 总结

- 确保 React Router 使用 `Switch` 来确保一次只渲染一个组件。
- 为动态组件设置唯一的 `key` 属性。
- 在组件卸载时正确处理生命周期方法。
- 检查 Koa 的缓存配置，确保页面内容更新时不会使用缓存的旧内容。
- 检查 `index.html` 的结构，确保只渲染一个 `root` 节点。

通过这些步骤，你应该能解决 React 路由跳转时旧内容未消失的问题。

# 17. koa-send

`koa-send` 是一个 Koa 中间件，用于在 Koa 应用中发送文件。例如，当你想在某个特定的路由中返回一个文件（比如一个 HTML 文件、图片、或下载的文件）时，可以使用 `koa-send` 来实现。

### 安装

首先，确保你已安装 `koa-send`：

```bash
npm install koa-send
```

### 基本使用

下面是 `koa-send` 的基本使用示例：

```javascript
const Koa = require('koa');
const path = require('path');
const send = require('koa-send');

const app = new Koa();

app.use(async (ctx) => {
  if (ctx.path === '/download') {
    // 发送一个文件作为响应
    await send(ctx, 'example.pdf', { root: path.join(__dirname, 'public') });
  } else if (ctx.path === '/') {
    // 发送 index.html 文件
    await send(ctx, 'index.html', { root: path.join(__dirname, 'public') });
  } else {
    // 处理其他路由
    ctx.body = 'Hello Koa';
  }
});

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

### 详细解释

- **`send(ctx, filePath, options)`**：
  - `ctx`：Koa 的上下文对象，包含请求和响应的信息。
  - `filePath`：要发送的文件的路径。这个路径是相对于 `root` 选项的。
  - `options`：一个对象，包含一些配置选项，比如 `root`（根目录路径），用于确定文件的实际路径。

- **`root`**：指定文件的根目录，所有文件路径都相对于这个目录。例如，如果 `root` 设置为 `public`，并且 `filePath` 设置为 `example.pdf`，`koa-send` 将会尝试发送 `public/example.pdf`。

### 常见用法

#### 1. **处理静态文件请求**

虽然你通常会使用 `koa-static` 来处理静态文件请求，但你也可以使用 `koa-send` 来手动处理这些请求：

```javascript
app.use(async (ctx) => {
  if (ctx.path.startsWith('/static')) {
    // 发送静态文件
    await send(ctx, ctx.path, { root: path.join(__dirname, 'public') });
  }
});
```

#### 2. **提供文件下载**

当你希望用户能够下载一个文件时，可以使用 `koa-send`：

```javascript
app.use(async (ctx) => {
  if (ctx.path === '/download') {
    await send(ctx, 'example.pdf', { root: path.join(__dirname, 'downloads'), setHeaders: (res, path, stats) => {
      res.setHeader('Content-Disposition', 'attachment; filename="example.pdf"');
    }});
  }
});
```

在这个例子中，`setHeaders` 选项用于设置自定义 HTTP 头，比如 `Content-Disposition`，从而指示浏览器将文件作为附件下载。

### 总结

`koa-send` 是一个简单但功能强大的工具，用于在 Koa 中发送文件。无论是提供静态资源还是实现文件下载功能，`koa-send` 都能够轻松胜任。你可以根据不同的路由条件使用它来发送特定的文件内容。

# 18. Koa-send和Koa-static有区别吗？













