# 1 webpack是如何做性能优化


## 1.1 开发环境

1. 优化代码调试: source-map
2. 优化打包速度: HMR Hot module replacement

## 2.1 生产环境

1. 优化打包体积
2. 优化打包速度：oneOf——提升构建速度；对babel进行缓存；
3. 优化代码调试: source-map
4. 优化线上运行速度：使用hash对资源进行缓存

# 2 tree-shaking的用途，原理

## 2.1 原理

- 基于ES2015模块的**静态解析特性**。
- 当使用**ES2015模块语法**时，可以在代码中使用import和export关键字来申明依赖关系。
- 这些依赖关系可以被静态分析，以确定哪些代码被使用，哪些代码未被使用。
- 基于此，可以删除未使用的代码。
- 在实际应用中，需要使用Tree-shaking技术的构建工具，如Webpack，Rollup等。
- 这些工具可以依据依赖关系构建依赖图，然后使用Tree-Shaking算法来删除未使用的代码，最终生成精简的代码包。





# 3 用过哪些loader

https://juejin.cn/post/6844904094281236487

- **`babel-loader`**：将代码中的es6+语法转换为es5语法，以便在旧版浏览器中运行

- **`ts-loader`**：将TypeScript转换成Javascript，在内部是调用了TypeScript的官方编译器-tsc。所以ts-loader和tsc是共享tsconfig.json

  - 浏览器能识别TS吗？为什么要运行`tsc xxx.ts`命令（即运行TypeScript编译器），去生成js文件

  - ```html
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
      </head>
      <body></body>
      <script src="./index.js"></script>
      <script src="./index2.ts"></script>
    </html>
    ```

  - html中引入ts文件会报错：`Refused to execute script from 'http://127.0.0.1:5500/TypeScript/TypeScriptCode/index2.ts' because its MIME type ('video/mp2t') is not executable.`

- **`css-loader`**：将css文件编译成[**commonjs模块**](E:\TechDocument\js模块化\01.md)，加载到js中，里面内容是样式字符串

- **`style-loader`**：创建style标签，将js中的css样式资源插入进去，添加到页面head中生效

# 4 用过哪些plugin

https://juejin.cn/post/6844904094281236487

# 5 Loader和Plugin的区别

https://juejin.cn/post/6844904094281236487

- `Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作
- 插件接口允许用户直接介入编译过程。 插件可以在不同时期运行的生命周期挂钩上注册回调函数。 在单个编译流程中，当每个钩子都被执行后，插件将拥有 当前编译流程的完整访问权限

# 6 Webpack构建流程

https://juejin.cn/post/6844904094281236487

Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

- `初始化参数`：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- `开始编译`：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- `确定入口`：根据配置中的 entry 找出所有的入口文件
- `编译模块`：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
- `完成模块编译`：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
- `输出资源`：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
- `输出完成`：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

简单说

- 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler
- 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中

对源码感兴趣的同学可以移步我的另一篇专栏[从源码窥探Webpack4.x原理](https://juejin.cn/post/6844904046294204429)





























