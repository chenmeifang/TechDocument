https://www.bilibili.com/video/BV1ev411P7jn/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

  "react-dom": "^18.2.0",

  "react-dom": "^17.0.1",

https://www.bilibili.com/video/BV13j411D7K6/?spm_id_from=333.788.recommend_more_video.11&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

# 1.配置React源码本地调试环境

注意：

![image-20240307202439100](源码.assets/image-20240307202439100.png)

1.使用create-react-app脚手架创建项目

​	`npx create-react-app react-test`

2.弹射create-react-app

​	`npm run eject`

3.克隆react官方源码

​	`git clone --branch v16.13.1 --depth=1 https://github.com/facebook/react.git src/react`

4.链接本地源码

```javascript
// 文件位置：react-test/config/webpack.config.js
resolve: {
      alias: {
        'react-native': 'react-native-web',                
        "react": path.resolve(__dirname, "../src/react/packages/react"),
        "react-dom": path.resolve(__dirname, "../src/react/packages/react-dom"),
        "shared": path.resolve(__dirname, "../src/react/packages/shared"),
        "react-reconciler": path.resolve(__dirname, "../src/react/packages/react-reconciler"),
        "legacy-events": path.resolve(__dirname, "../src/react/packages/legacy-events"),
      }
}
```

==问题：path.resolve(__dirname，‘xxx’)不熟==

5.修改环境变量

```javascript
// 文件位置：react-test/config/env.js
const stringified = {
    'process.env': Object.keys(raw).reduce((env, key) => {
      env[key] = JSON.stringify(raw[key]);
      return env;
    }, {}),
    __DEV__: true,
    SharedArrayBuffer: true,
    spyOnDev: true,
    spyOnDevAndProd: true,
    spyOnProd: true,
    __PROFILE__: true,
    __UMD__: true,
    __EXPERIMENTAL__: true,
    __VALIANT__: true,
    gate: true,
    trustedTypes: true
};
```

6.告诉babel在转换代码时忽略类型检查

`npm install @babel/plugin-transform-flow-strip-types -D`

```javascript
// 文件位置：react-test/config/webpack.config.js [babel-loader]
plugins: [
    require.resolve("@babel/plugin-transform-flow-strip-types"),
]
```

7.导出HostConfig

```javascript
// 文件位置: react\packages\react-reconciler\src\ReactFiberHostConfig.js
+ export * from './forks/ReactFiberHostConfig.dom';
```

![image-20240306211106420](源码.assets/image-20240306211106420.png)

8.修改ReactSharedInternals.js文件

```javascript
// 文件位置：react\packages\shared\ReactSharedInternals.js
- import * as React from 'react';
- const ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+ import ReactSharedInternals from '../react/src/ReactSharedInternals';
```

9.关闭eslint扩展

![image-20240306203849889](源码.assets/image-20240306203849889.png)

10.禁止invariant报错

```javascript
if (condition) return;
```

![image-20240306203950405](源码.assets/image-20240306203950405.png)

11.eslint配置

在react源码文件夹中新建.eslintrc.json并添加如下配置

```javascript
{
    "extends": "react-app",
    "globals": {
        "SharedArrayBuffer": true,
        "spyOnDev": true,
        "spyOnDevAndProd": true,
        "spyOnProd": true,
        "__PROFILE__": true,
        "__UMD__": true,
        "__EXPERIMENTAL__": true,
        "__VALIANT__": true,
        "gate": true,
        "trustedTypes": true
    }
}
```

12.修改react react-dom引入方式

![image-20240306204242420](源码.assets/image-20240306204242420.png)

13.解决vsCode中flow报错

![image-20240306204408448](源码.assets/image-20240306204408448.png)

14.可选项配置

![image-20240306204701035](源码.assets/image-20240306204701035.png)

15.____DEV____报错

删除node_modules，执行npm Install

# 2.创建React元素

https://www.bilibili.com/video/BV13j411D7K6/?p=2&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

**jsx代码会被babel转换成React.createElement代码的调用**

## 2.1 createElement

[JSX转换为ReactElement的过程](https://www.bilibili.com/video/BV13j411D7K6?p=2&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

- react元素：就是之前所说的virtual dom，实际上就是js对象，用来描述真实dom对象长成什么样子

- 在react项目运行之前，jsx会被babel进行转换，每一段jsx语法都会被babel转换为React.createElement方法的调用，返回react元素
- jsx是如何被转换为react元素的？

## 2.2 ReactElement

## 2.3 hasValidRef

## 2.4 hasValidKey

## 2.5 isValidElement

## 2.6 defineKeyPropWarningGetter

## 2.7 defineRefPropWarningGetter

# 3.React架构

[React16版本架构](https://www.bilibili.com/video/BV13j411D7K6/?p=5&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

- 调度层：负责调度任务的优先级，高优先级任务优先进入到协调器当中。要保证react代码在浏览器的空闲时间去执行
  - ==怎么判断任务的优先级？==
- 协调层：负责构建Fiber数据结构，比对Fiber对象找出差异，记录Fiber对象要进行的dom操作
- 渲染层：负责将发生变化的部分渲染到页面当中

## 3.1 Scheduler 调度层

<img src="源码.assets/image-20240312082608439.png" alt="image-20240312082608439" style="zoom:80%;" />

- 在react 15中是没有调度层的，为什么要在react 16中加入调度层呢？
  - 因为react 15中采用了**循环加递归**的方式进行**virtualDOM的比对**，==由于递归使用的是Javascript自身的执行栈，==一旦开始就无法停止，直到任务执行完成
  - 如果virutal dom树的层级比较深，vitural dom的比对就会长期占用Javascript主线程，由于js又是单线程的，没有办法同时去执行其他任务，所以在比对的过程当中，就无法同时响应用户的操作，无法及时执行元素动画，就造成了页面卡顿的现象
  - 为了解决卡顿的问题，在react 16中就加入了调度层
- react 16，所有的任务并不是直接去执行，而是要先被加入到任务队列中，等到浏览器有空闲时间了，才去执行
- react 16中，放弃了使用js递归的方式进行vitural dom的比对，而是采用循环去模拟递归。这样任务在执行的过程当中，如果浏览器没有空闲时间了，任务也可以随时被中断

## 3.2 Reconciler 协调层

- react 15中，协调层和渲染层是交替执行的，即找到了差异就直接去更新差异
- react 16中，协调层和渲染层不再交替执行，**协调层负责构建Fiber节点，找出差异**，在所有差异找出之后，统一交给渲染层进行dom的更新
- **协调层的主要任务：找出差异部分，并为差异打上标记**

## 3.3 Renderer 渲染层

- 渲染层根据协调层为Fiber节点打的标记，同步执行对应的dom操作
- 比对的过程从递归变成了可以中断的循环，那么react是如何解决中断更新时dom渲染不完全的问题呢？
  - ==其实根本就不存在这个问题，因为在整个的更新过程当中，调度层和协调层的工作是在内存当中完成的，是可以被打断的；而渲染层的工作被设定成不可以被打断，所以不存在dom渲染不完全的问题==

# 4.数据结构

[Fiber数据结构介绍](https://www.bilibili.com/video/BV13j411D7K6/?p=6&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

## 4.1 Fiber

react元素：就是之前所说的virtual dom，实际上就是js对象，用来描述真实dom对象长成什么样子

Fiber其实就是js对象，它是从virtural dom对象演变而来的

在fiber对象中，有很多属性，主要分为四类：

- 和dom实例对象相关
  - tag：用来区分组件的类型，当前fiber节点表示的是函数组件还是类组件，还是普通的react元素呢？还是一些其他的组件类型呢？
  - type：createElement方法的第一个参数，表示节点的类型，如果当前节点是div或者span，type属性存储的就是字符类型的div，span；如果当前元素是组件，type属性当中存储的就是组件的构造函数
  - stateNode
    - 如果当前fiber表示的是普通dom节点，stateNode属性当中存储的就是节点对应的真实dom对象；
    - 如果当前fiber表示的是类组件，stateNode属性当中存储的就是类组件的实例对象；
    - 如果当前fiber表示的是函数组件，stateNode属性当中存储的就是null，因为函数组件没有实例

- 和构建fiber树相关的
  - return：父级fiber节点
  - child：子级fiber节点
  - sibling：下一个兄弟fiber节点

- 和组件状态相关的
  - pendingProps：组件中即将更新的props
  - memoizedProps：旧的props
  - memoizedState：旧的state

- 和副作用相关的属性（可以触发dom操作的属性）
  - updateQueue：**在setState方法被调用，更新并不是马上发生的，react会将多个更新操作放在updateQueue队列当中，最后执行批量更新操作**
  - effectTag：当前fiber节点对应的don节点要进行什么样的操作
  - firstEffect
  - nextEffect
  - lastEffect
  - expiration：过期时间，如果因为任务优先级的关系，任务迟迟没有得到执行，如果超过任务的过期时间，react就会强制执行该任务；如果是同步任务，这个过期时间会被设置成一个很大的数值
  - mode：表示当前fiber节点的模式

<img src="源码.assets/image-20240312083647606.png" alt="image-20240312083647606" style="zoom: 80%;" />

<img src="源码.assets/image-20240312083835967.png" alt="image-20240312083835967" style="zoom:80%;" />

## 4.2 WorkTag

<img src="源码.assets/image-20240312083622814.png" alt="image-20240312083622814"  />

- 0：函数组件
- 1：类组件
- 3：当前组件挂载点对应的fiber对象 默认情况就是id为root的div节点对应的fiber对象
- 5：普通的react节点，比如：div span

## 4.3 TypeOfMode

<img src="源码.assets/image-20240312084449824.png" alt="image-20240312084449824"  />

## 4.3 SideEffectTag

表示的是当前fiber 节点对应的dom节点要进行什么样的操作

<img src="源码.assets/image-20240312084202659.png" alt="image-20240312084202659" style="zoom:80%;" />

## 4.4 Update

## 4.5 UpdateQueue

## 4.6 RootTag

## 4.7 双缓存技术

[双缓存技术介绍](https://www.bilibili.com/video/BV13j411D7K6?p=7&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

<img src="源码.assets/image-20240312123731138.png" alt="image-20240312123731138" style="zoom:80%;" />

**fiber节点对象中是存储了对应的dom节点对象的，也就是说，dom对象的构建是在内存当中完成的，当所有fiber对象构建完成后，所有的dom对象就也构建完成了。这时就可以直接使用内存当中的dom对象替换页面当中的dom对象了**

## 4.8 区分fiberRoot与rootFiber

https://www.bilibili.com/video/BV13j411D7K6?p=8&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

![image-20240312124531070](源码.assets/image-20240312124531070.png)

# 5.初始化渲染

[render方法解析](https://www.bilibili.com/video/BV13j411D7K6?p=9&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

react元素是如何渲染到页面中的？

## 5.1 render阶段

协调层负责的阶段，在这个阶段当中，要为每一个react元素构建对应的fiber对象，在构建fiber对象的过程当中，还要为此fiber对象创建其对应的dom对象，并且还要为fiber对象添加EffectTag属性

### 5.1.1 render

![image-20240312131700124](源码.assets/image-20240312131700124.png)

### 5.1.2 isValidContainer

![image-20240312171043554](源码.assets/image-20240312171043554.png)

### 5.1.3 初始化FiberRoot

[创建fiberRoot对象和rootFiber对象](https://www.bilibili.com/video/BV13j411D7K6?p=10&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

**legacyRenderSubtreeIntoContainer：初始化Fiber数据结构——创建fiberRoot以及rootFiber**

![image-20240312171359642](源码.assets/image-20240312171359642.png)

![image-20240312172937768](源码.assets/image-20240312172937768.png)

![image-20240312174525736](源码.assets/image-20240312174525736.png)

![image-20240312174627588](源码.assets/image-20240312174627588.png)

![image-20240312174721474](源码.assets/image-20240312174721474.png)

==为什么要清除container中的元素？==

![image-20240312175146350](源码.assets/image-20240312175146350.png)

==什么是LegacyRoot？==

![image-20240312175400531](源码.assets/image-20240312175400531.png)

![image-20240312180256363](源码.assets/image-20240312180256363.png)

![image-20240312180412243](源码.assets/image-20240312180412243.png)

![image-20240312180707801](源码.assets/image-20240312180707801.png)

![image-20240312180813852](源码.assets/image-20240312180813852.png)

![image-20240312180931799](源码.assets/image-20240312180931799.png)

### 5.1.4 获取rootFiber.child实例对象

### 5.1.5 updateContainer

https://www.bilibili.com/video/BV13j411D7K6?p=12&spm_id_from=pageDriver&vd_source=a7089a0e007e4167b4a61ef53acc6f7e

## 5.2 commit阶段

- 在commit阶段当中，会先获取到render阶段的工作成果，就是获取到保存在FiberRoot对象当中的新构建的workingProgressFiber树
- 接下来就是根据fiber对象中的effectTag属性进行相应的dom操作
