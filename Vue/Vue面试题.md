# 1. v-if和v-show的区别

在 Vue.js 中，`v-if` 和 `v-show` 都是用于控制元素显示与隐藏的指令，但它们的工作原理、性能和使用场景有所不同。下面是它们的主要区别：

### 1. **工作原理**

- **`v-if`**：
  - `v-if` 是 **条件渲染**，它会根据条件的真假决定是否渲染元素。
  - 如果条件为 `false`，对应的 DOM 元素将 **完全销毁**，而如果条件为 `true`，元素才会被 **创建** 并插入到 DOM 中。
  - 由于是 **动态创建和销毁** 元素，因此它的 **性能消耗相对较大**，尤其是在频繁切换的情况下。
- **`v-show`**：
  - `v-show` 是 **显示和隐藏** 元素，基于 `CSS` 的 `display` 属性控制元素的显示与隐藏。
  - 当 `v-show` 的条件为 `false` 时，元素的 `display` 被设置为 `none`，但元素 **始终存在于 DOM 中**，只是 **不可见**。
  - 由于 `v-show` 不会销毁和重新创建 DOM 元素，所以它的 **性能开销较小**，适合用来控制频繁切换的元素显示。

### 2. **性能**

- **`v-if`**：
  - 初次渲染时，`v-if` 的开销较大，因为它涉及到 **DOM 的创建和销毁**，因此不适合用于频繁切换的元素。
  - 在 **条件变化不频繁** 的情况下，`v-if` 适合使用，因为它仅会在条件为 `true` 时渲染一次元素。
- **`v-show`**：
  - `v-show` 的初次渲染时相对较轻，因为它 **只改变 `display` 属性**，不会销毁或重新创建 DOM。
  - 在 **频繁切换显示和隐藏** 的场景下，`v-show` 性能较优。

### 3. **使用场景**

- **`v-if` 适用场景**：
  - 当你 **不需要频繁切换** 显示状态时，使用 `v-if`。
  - 如果需要进行 **条件渲染**，并且希望元素只有在条件成立时才创建，`v-if` 是最佳选择。
  - 例如，用户权限控制、表单验证等场景，只有在条件成立时才显示对应内容。
- **`v-show` 适用场景**：
  - 当你 **频繁切换显示状态** 时，使用 `v-show` 更合适。
  - 适合用在频繁需要隐藏和显示的场景，如选项卡切换、动画等。
  - 如果元素仅仅是显示或隐藏而不会重新生成，`v-show` 更为高效。

### 4. **初始渲染性能**

- **`v-if`**：
  - 初次渲染时，如果条件为 `true`，元素将被创建并插入到 DOM 中，否则该元素完全不渲染。
- **`v-show`**：
  - 初次渲染时，元素会被渲染并插入 DOM 中，但即使条件为 `false`，它也会存在于 DOM，只是通过 `display: none` 隐藏。

### 5. **模板语法差异**

- **`v-if`**：

  ```html
  <div v-if="isVisible">This is visible when isVisible is true</div>
  ```

- **`v-show`**：

  ```html
  <div v-show="isVisible">This is visible when isVisible is true</div>
  ```

### 6. **内存使用**

- **`v-if`**：
  - 在条件为 `false` 时，DOM 元素会被销毁。若条件变为 `true`，DOM 元素会重新创建，这可能会占用更多的内存，特别是在频繁的创建和销毁中。
- **`v-show`**：
  - 即使元素不可见，它依然存在于 DOM 中，因此会占用一定的内存，尤其是元素较多时。

------

### 总结：

| 特性         | `v-if`                                            | `v-show`                                     |
| ------------ | ------------------------------------------------- | -------------------------------------------- |
| 渲染方式     | 条件渲染：条件为 `true` 时渲染，为 `false` 时销毁 | 显示/隐藏：通过修改 `display` 控制显示与隐藏 |
| 性能开销     | 条件切换时销毁和重建 DOM 元素，性能较差           | 只通过修改 `display` 样式，性能较好          |
| 使用场景     | 初始渲染开销大，适合条件不常变动的场景            | 频繁切换显示状态的场景，如选项卡切换         |
| 内存使用     | 条件为 `false` 时销毁 DOM，内存使用较少           | 即使隐藏，元素依然存在于 DOM 中，占用内存    |
| 初次渲染开销 | 较大，涉及到 DOM 的创建和销毁                     | 较小，只有 `display` 样式的改变              |

**选择使用哪个指令**，通常根据你的实际需求来决定。如果你需要频繁切换显示与隐藏，`v-show` 更为合适；如果你希望根据条件来动态渲染元素，则应该使用 `v-if`。

# 2. vue2中的数组问题及解决方法

在 Vue 2 中，数组的问题通常涉及数组变更的 **响应式更新**。Vue 2 使用 `Object.defineProperty` 进行响应式数据的代理，这导致了一些数组操作可能无法触发视图更新。具体来说，数组的某些方法可能不会触发视图更新，尤其是当你直接修改数组的索引或者使用数组的一些变异方法时。

### 1. **问题描述**

#### 1.1 **直接修改数组索引**

在 Vue 2 中，直接通过索引修改数组元素可能不会触发视图更新。原因是 `Object.defineProperty` 只能代理对象的属性，而数组的索引是通过数值下标来访问的，这种方式 Vue 无法对数组索引做出响应式处理。

**例子：**

```js
// 假设我们有一个 Vue 实例
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    updateArray() {
      this.arr[1] = 4;  // 直接修改索引
    }
  }
});
```

在上面的代码中，`this.arr[1] = 4` 直接修改数组的第二个元素。然而，Vue 不能通过 `Object.defineProperty` 代理数组索引的变更，因此 **视图不会更新**。

#### 1.2 **使用数组的变异方法（如 `push`、`splice`）**

虽然 Vue 2 能够监控大部分数组变异方法（例如 `push`、`pop`、`shift`、`unshift`、`splice`、`sort` 和 `reverse`），但这些方法也有一些限制，尤其是当你在某些特定情况下修改数组时，Vue 可能不会检测到数组的变化。

**例子：**

```js
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    addToArray() {
      this.arr.push(4);  // 使用 push 方法
    }
  }
});
```

上面的代码使用 `push` 添加元素，这种操作 Vue 是能监听到的，视图会正常更新。但如果你在数组的某些特殊情况下变更它们，Vue 可能没有办法完全监控所有情况。

------

### 2. **解决方法**

Vue 提供了几种方法来处理数组响应式更新问题，以确保数组的修改能够正确触发视图更新。

#### 2.1 **使用 `Vue.set` 或 `this.$set`**

对于直接修改数组索引或修改数组某一项的情况，可以使用 `Vue.set` 或 `this.$set` 来确保数据的响应式更新。这两者的作用是确保 Vue 可以检测到数组的变更，并且触发视图更新。

**例子：**

```js
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    updateArray() {
      // 使用 Vue.set 来修改数组的某一项
      this.$set(this.arr, 1, 4);  // 将 arr[1] 设置为 4
    }
  }
});
```

在上面的例子中，`this.$set(this.arr, 1, 4)` 修改了 `arr` 数组的第二项 `arr[1]`，并确保这个变化会触发视图更新。

#### 2.2 **使用数组的变异方法（`push`、`splice` 等）**

对于常见的数组操作如 `push`、`pop`、`shift`、`unshift`、`splice` 等，Vue 2 会自动检测这些变动并更新视图。但如果需要确保一些特殊情况的数组变动被检测到，可以使用 `Vue.set`。

**例子：**

```js
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    addToArray() {
      // 使用 push 添加数据时，Vue 会自动响应
      this.arr.push(4);
    },
    removeItem() {
      // 使用 splice 删除元素
      this.arr.splice(1, 1); // 删除索引为 1 的元素
    }
  }
});
```

在上述代码中，`this.arr.push(4)` 和 `this.arr.splice(1, 1)` 都是 Vue 内部支持的变异方法，会自动触发视图更新。

#### 2.3 **使用数组的 `splice` 方法修改数组**

当你需要修改数组的某个部分（例如，替换数组的某个元素或插入新元素），`splice` 方法是一个很好的选择。

**例子：**

```js
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    updateArray() {
      // 使用 splice 来修改数组
      this.arr.splice(1, 1, 4);  // 删除 arr[1] 并插入 4
    }
  }
});
```

在上述代码中，`this.arr.splice(1, 1, 4)` 删除了 `arr[1]` 元素，并将其替换为 `4`。`splice` 是 Vue 内部能够正确检测到的变异方法，视图将会更新。

#### 2.4 **使用 `Object.assign()` 或数组的 `concat` 合并数组**

当你需要合并数组时，可以使用 `Object.assign()` 或 `concat()` 来确保 Vue 能正确处理数组更新。

**例子：**

```js
new Vue({
  el: '#app',
  data: {
    arr: [1, 2, 3]
  },
  methods: {
    mergeArrays() {
      // 使用 concat 合并数组
      this.arr = this.arr.concat([4, 5]);
    }
  }
});
```

使用 `concat()` 合并数组，Vue 会通过替换整个数组来触发视图更新。

#### 2.5 **避免直接修改数组的索引**

虽然 Vue 2 可以通过 `Vue.set` 或 `this.$set` 来修改数组的特定项，但为了避免复杂的响应式问题，建议尽量避免直接修改数组的索引，而是使用 Vue 提供的变异方法，如 `push`、`splice` 等。

------

### 总结

在 Vue 2 中，数组响应式的问题主要出现在直接修改数组索引和某些变异方法（如 `push`、`splice` 等）。为了确保数组变更能够正确触发视图更新，推荐的做法是：

- 使用 `Vue.set` 或 `this.$set` 来修改数组的元素。
- 使用 `push`、`splice` 等 Vue 能自动检测的变异方法。
- 尽量避免直接通过索引修改数组。

这些方法可以帮助你确保 Vue 对数组变更做出响应，从而保持数据与视图的同步。

# [3. Vue和React的区别](https://www.bilibili.com/video/BV1aZ4y1F7BK/?spm_id_from=333.337.search-card.all.click&vd_source=a7089a0e007e4167b4a61ef53acc6f7e)

|          |                        Vue                        |                  React                   |
| :------: | :-----------------------------------------------: | :--------------------------------------: |
| 框架定位 |                **数据响应式**框架                 | 强调**单向数据流**，跟数据响应式是对应的 |
|   语法   |                     template                      |                   jsx                    |
| Diff算法 | Vue2：双端比较<br />Vue3：双端比较+最长递增子序列 |                  仅右移                  |
|   CSS    |                     CSS Scope                     |                                          |

 